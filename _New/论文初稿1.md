#### 前言
当今，许多的主流策略类型的游戏都在使用网格地图(HexGrid)，其中包括《奇迹时代3》、《文明6》、《无尽传奇》、《英雄无敌》等著名的3A游戏。网格地图具有生成快速、完全程序化控制、易于解析和存储等优势，相比于用传统美术等方式制作游戏地图，对移动端设备更加友好，可以大幅度减少美术资源数量，安装包更小，更容易被用户接受。

#### 1. HexMap形状
在传统的回合制游戏中，尤其是日式RPG游戏，大多使用正方形网格地图。
在大多数回合策略游戏中，使用对网格地图通常有两种：正方形和正六边形。目前，越来越多的游戏已经逐渐从正方形转变到了正六边形。

为什么使用六边形的网格地图？在传统游戏中，尤其是传统的日式RPG中，大量的使用了正方形的网格地图。正方形网格相比其他形状，更容易绘制和定位。但是正方形网格也有明显的缺点，下图为一个正方形网格：

![一个正方形网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/square-grid.png)

中间这个正方形网格中，一共有8个与其相邻的网格。与中间正方形网格边相邻的网格，称为水平和垂直相邻，与中间正方形网格对角相邻的网格，称为对角相邻。
从上图中可以看出，如果每个正方形网格的边长为1，那么，水平和垂直相邻的正方形网格中点之间的距离也为1.但是，对角相邻的正方形网格中点之间的距离，为$\sqrt{ 2 }$。
两种形式的相邻网格，造成了距离的差异化。在游戏中，如果一个人物在正方形网格中进行移动，这种距离的差异化将会更加明显。为了避免这种差异化，不同的游戏使用了不同的方法，也有不同的有点和缺点。其中一种方法，就是使用正六边形网格代替传统的正方形网格。

![六边形网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/hexagon-grid.png)

与正方形网格相比，在正六边形网格中，每个地图块之间中点的距离都是相等的，这样就避免了距离的差异化。当然，使用正六边形网格也会有其他的问题，不过相对于距离差异化更容易解决。

![六边形的内外半径](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/hexagon.png)

在开始设计正六边形网格地图之前，必须先确定每个正六边形地图块的边长。如果一个正六边形地图块的边长为10，那么，这个正六边形地图块的外接圆半径也是10。
每个正六边形网格还有一个内切圆，根据勾股定理可以得出，其内切圆的半径为 $\frac{ \sqrt{ 3 } }{ 2 }$ 倍的边长，得出内切圆半径为 $5\sqrt{ 3 }$。
接下来，将这两个常量保存至一个静态类中，便于访问。代码如下：

```csharp
using UnityEngine;

public static class HexMetrics
{
    public const float outerRadius = 10f;

    public const float innerRadius = outerRadius * 0.866025404f;
}
```

确定了整列变形地图块的外接圆和内切圆半径后，接下来需要确定正六边形网格中，每个正六边形地图块的摆放姿态。
在正六边形网格中，每个正六边形地图块会有两种摆放姿态，顶点朝上或者边朝上。

![正六边形地图块的摆放姿态](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/orientations.png)

为了方便计算与排列，这里选择顶点朝上的排列方式，并将正六边形网格放置在XZ平面上。从正六边形地图块正上方一个顶点的位置开始，顺时针排列一个其相邻的六个地图块。以下代码为记录每个正六边形地图块其六个顶点位置：

```csharp
    public static Vector3[] corners =
    {
        new Vector3(0f, 0f, outerRadius),
        new Vector3(innerRadius, 0f, 0.5f * outerRadius),
        new Vector3(innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(0f, 0f, -outerRadius),
        new Vector3(-innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(-innerRadius, 0f, 0.5f * outerRadius)
    };
```

#### 2. 创建地图网格
要创建一个正六边形网格，需要先创建单个的正六边形地图块。在Unity3D中，可以将一个正六边形地图块制作为Prefab，方便程序引用和统一修改。讲每个正六边形地图块称为HexCell，并串讲基础脚本：

```csharp
using UnityEngine;

public class HexCell : MonoBehaviour
{
}
```

创建正六边形地图块Prefab非常简单，首先，在场景中创建一个Plane，并挂载HexCell.cs脚本，然后将其转换成Prefab，结果如下图：

![使用plane作为HexCell Prefab](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/hex-cell-plane.png)

接下来，要创建一个容器，用来实例化正六边形地图块，并将每个地图块有序的排列起来。其名称为HexGrid。脚本与参数如下图：

```csharp
using UnityEngine;

public class HexGrid : MonoBehaviour
{
    public int width = 6;
    public int height = 6;

    public HexCell cellPrefab;
}
```

![HexGrid 属性](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/hex-grid.png)

由于HexCell使用了Plane网格，Plane网格默认为 10x10 单位长度，所以在实例化HexCell时，需要加上边长的偏移量。实例化HexCell代码与生成无缝单元网格效果如下：

```csharp
    private HexCell[] cells;

    void Awake()
    {
        cells = new HexCell[height * width];

        for (int z = 0, i = 0; z < height; z++)
        {
            for (int x = 0; x < width; x++)
            {
                CreateCell(x, z, i++);
            }
        }
    }

    void CreateCell(int x, int z, int i)
    {
        Vector3 position;
        position.x = x * 10f;
        position.y = 0f;
        position.z = z * 10f;

        HexCell cell = Instantiate<HexCell>(cellPrefab);
        cells[i] = cell;

        cell.transform.SetParent(transform, false);
        cell.transform.localPosition = position;
    }
```

![生成的无缝单元网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/square-grid-of-planes.png)

虽然按照程序生成了相应网格，但是在程序调试过程中无法判断每个HexCell的位置，如果HexCell为正六边形，这个问题将会更加棘手。

#### 3. 显示坐标
要显示每个HexCell的坐标，可以使用Unity3D的UGUI系统来实现。创建一个Canvas，并将其设置为HexGrid的子物体。因为目前功能只需要显示坐标，不需要任何触发，所以删除Canvas上的Graphic Raycaster组件。下图为HexGridCanvas参数设置：

![HexGridCanvas参数设置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/canvas.png)

在Unity3D UGUI中，Canvas是承载UI元素的容器，要显示每个HexCell的坐标，需要在Canvas容器中创建一个Text对象，并将这个Text对象转换为Prefab。Text对象的参数设置如下图：

![Text对象参数设置 1](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/label-part-1.png)
![Text对象参数设置 2](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/label-part-2.png)

接下来，要在初始化HexCell时，同时初始化HexCellLabel，并且让每一个HexCellLabel与HexCell对齐，修改HexGrid.cs脚本与运行效果如下：
```csharp
using UnityEngine.UI;

    public Text cellLabelPrefab;

    Canvas gridCanvas;

    void Awake ()
    {
    gridCanvas = GetComponentInChildren<Canvas>();

        …
    }

    void CreateCell (int x, int z, int i)
    {
        …

        Text label = Instantiate<Text>(cellLabelPrefab);
        label.rectTransform.SetParent(gridCanvas.transform, false);
        label.rectTransform.anchoredPosition = new Vector2(position.x, position.z);
        label.text = x.ToString() + "\n" + z.ToString();
    }
```
![显示地图块的坐标](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/grid-with-labels.png)

#### 4. 设置地图块的位置
当前实例化的底图块为正方形而不是正六边形，如果要显示为正六边形地图块，需要修改每一个HexCell实例的位置，如下图所示，横向的两个正六边形地图块中点之间的距离为内切圆半径的2倍，纵向的两个正六边形地图块中点之间的距离，为外接圆半径的1.5倍。修改HexGrid.cs中CreateCell方法，使实例化每一个HexCellLabel与HexCell时，都出现在正确的位置。

![正六边形地图块的位置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/neighbor-distances.png)

```csharp
        position.x = x * (HexMetrics.innerRadius * 2f);
        position.y = 0f;
        position.z = z * (HexMetrics.outerRadius * 1.5f);
```

注意，正方形地图块的排列方式与正六边形地图块的排列方式还有一处不同，就是上下两排六边形地图块并不是位于彼此的正上方或正下方，而是彼此中点横向相差了内切圆半径的距离，所以，在HexGrid.cs的CreateCell方法中，需要增加这个偏移量，代码与运行效果图如下：

```csharp
        position.x = x * (HexMetrics.innerRadius * 2f) + z * HexMetrics.innerRadius;
```

![错开的地图块排列方式](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/rhombus.png)

现在，生成的地图网格整体为菱形，但是，在一般游戏中，使用矩形的地图网格会更加方便。所以，需要将偶数行地图块整体取消偏移量，修改HexGrid.cs的CreateCell方法，代码与运行结果如下所示：

```csharp
        position.x = (x + z * 0.5f - z / 2) * (HexMetrics.innerRadius * 2f);
```

![整体为正方形的地图网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/rectangular-area.png)

#### 5. 渲染正六边形地图块
每个地图块位置确定后，需要将目前的正方形地图块修改为正六边形地图块。首先需要删除HexCell Prefab上的Mesh Filter、Mesh Renderer、Mesh Collider组件，这样在实例化HexCell的时候就不会出现默认的正方形图案。如下图：

![修改后的HexCell Prefab](https://catlikecoding.com/unity/tutorials/hex-map/part-1/rendering-hexagons/empty-cell-prefab.png)

接下来，需要两个链表来记录所有正六边形中每个顶点与三角面片，创建HexMesh.cs脚本，新建一个GameOnject作为HexGrid的子物体，命名为HexMesh，并挂载HexMesh.cs脚本。HexMesh.cs代码及HexMesh参数配置如下：

```csharp
using UnityEngine;
using System.Collections.Generic;

[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class HexMesh : MonoBehaviour
{
    Mesh hexMesh;
    List<Vector3> vertices;
    List<int> triangles;

    void Awake()
    {
        GetComponent<MeshFilter>().mesh = hexMesh = new Mesh();
        hexMesh.name = "Hex Mesh";
        vertices = new List<Vector3>();
        triangles = new List<int>();
    }
}
```
![HexMesh参数配置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/rendering-hexagons/hex-mesh.png)

这样，HexGrid.cs脚本在初始化时，就可以引用HexMesh.cs进行网格的绘制，修改HexGrid.cs脚本如下

```csharp
    HexMesh hexMesh;

    void Awake()
    {
        gridCanvas = GetComponentInChildren<Canvas>();
        hexMesh = GetComponentInChildren<HexMesh>();

        …
    }
```

在Unity3D中，当所有脚本的Awake方法执行完毕后，才会执行每个脚本的Start方法，所以，确保HexMesh.cs初始化完成后，在HexGrid.cs脚本的Start方法中调用HexMesh.cs的网格绘制方法，在HexGrid.cs中添加的代码如下：

```csharp
void Start ()
    {
        hexMesh.Triangulate(cells);
    }
```

接下来，需要完成HexMesh.Triangulate方法，此方法主要先将之前可能残留在链表中的数据清除，之后获取当前的正六边形中点坐标，根据中点坐标绘制正六边形。接下来，将绘制完成的正六边形的顶点和三角面片信息，分别存储在两个链表中。最后，要根据生成的顶点与三角面片的信息，重新计算法线，保证视觉效果的正确性。

```csharp
    public void Triangulate(HexCell[] cells)
    {
        hexMesh.Clear();
        vertices.Clear();
        triangles.Clear();
        for (int i = 0; i < cells.Length; i++)
        {
            Triangulate(cells[i]);
        }
        hexMesh.vertices = vertices.ToArray();
        hexMesh.triangles = triangles.ToArray();
        hexMesh.RecalculateNormals();
    }

    void Triangulate(HexCell cell)
    {
    }
```

正六边形是由6个等边三角形面片构成的，在Unity3D中，会按照每3个一组的顶点位置信息来绘制三角面片。所以，每次以三个一组的数据绘制三角面片之前，分别将顶点信息和三角面片顺序信息存储在链表中。HexMesh.cs添加的代码如下：

```csharp
    void AddTriangle(Vector3 v1, Vector3 v2, Vector3 v3)
    {
        int vertexIndex = vertices.Count;
        vertices.Add(v1);
        vertices.Add(v2);
        vertices.Add(v3);
        triangles.Add(vertexIndex);
        triangles.Add(vertexIndex + 1);
        triangles.Add(vertexIndex + 2);
    }
```

正六边形中的每个顶点相对其中点的位置信息，都保存在HexMetrics类中，通过正六边形的中点位置，可以计算得出其6个顶点的位置，除了中点之外，从正上方顶点开始，每次取出两个相邻的顶点，进行三角面片的绘制。Triangulate重载方法的修改如下：

```csharp
    void Triangulate(HexCell cell)
    {
        Vector3 center = cell.transform.localPosition;

        for (int i = 0; i < 6; i++)
        {
            AddTriangle(
                center,
                center + HexMetrics.corners[i],
                center + HexMetrics.corners[i+1]
            );
        }
    }
```

注意，在以上循环加载整六边形顶点时，初始顶点和结束顶点位置相同，但是索引不同，需要在HexMetrics的corners数组中增加一个结束元素，否则循环到最后一个顶点的时候将会造成数组越界，修改corners数组代码如下：

```csharp
    public static Vector3[] corners =
    {
        new Vector3(0f, 0f, outerRadius),
        new Vector3(innerRadius, 0f, 0.5f * outerRadius),
        new Vector3(innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(0f, 0f, -outerRadius),
        new Vector3(-innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(-innerRadius, 0f, 0.5f * outerRadius),
        new Vector3(0f, 0f, outerRadius)
    };
```

最终运行效果如下图：

![完成效果](https://catlikecoding.com/unity/tutorials/hex-map/part-1/rendering-hexagons/complete-hexagons.png)

#### 6. 修正地图坐标
完成基本的正六边形绘制后，每个正六边形元素在Z轴方向上，坐标都很正常。但是在X轴方向上，所有的正六边形坐标都呈现锯齿状。这是为了填充每个正六边形之间空隙所产生的副作用，如下图所示：

![整六边形排列](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/offset-diagram.png)

这些偏移导致了在处理X坐标的时候会有些繁琐。在这里，需要一添加一个新的类，重新转换这些HexCell的坐标，使其更容易序列化，便于存储。并且在程序运行时，这些坐标数据不会被重新编译，保证了程序的运行效率。新建脚本HexCoordinates.cs，其中FromOffsetCoordinates静态方法负责将现有的坐标逐个读取进行转换，并返回转换后的新坐标。代码如下：

```csharp
using UnityEngine;
using System;

[Serializable]
public struct HexCoordinates
{
    public int X { get; private set; }

    public int Z { get; private set; }

    public HexCoordinates(int x, int z)
    {
        X = x;
        Z = z;
    }

    public static HexCoordinates FromOffsetCoordinates(int x, int z)
    {
        return new HexCoordinates(x, z);
    }
}
```

为了更加方便地显示坐标数值，这里要重写ToString方法。因为原有的ToString方法只会显示方法名或者结构体名，这里需要在一行中直接输出X与Z的坐标值，同时再添加一个X与Z的坐标值分别在单独行显示的方法。代码如下：

```csharp
    public override string ToString()
    {
        return "(" + X.ToString() + ", " + Z.ToString() + ")";
    }

    public string ToStringOnSeparateLines()
    {
        return X.ToString() + "\n" + Z.ToString();
    }
```

接下来，在HexCell.cs初始化的时候，就可以使用HexCoordinates进行坐标的记录、转换和输出了。HexCell.cs代码修改如下：

```csharp
public class HexCell : MonoBehaviour
{
    public HexCoordinates coordinates;
}
```

在HexGrid.cs创建正HexCell的时候，就可以直接调用HexCoordinates结构体中的方法输出当前HexCell的坐标值了，HexGrid.cs中CreateCell方法添加如下代码：

```csharp
        cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);
        label.text = cell.coordinates.ToStringOnSeparateLines();
```

然后，就可以很方便的在结构体HexCoordinates的FromOffsetCoordinates方法中调整HexCell的坐标了。为了抵消X方向的偏移，修改其代码如下：

```csharp
    public static HexCoordinates FromOffsetCoordinates(int x, int z)
    {
        return new HexCoordinates(x - z / 2, z);
    }
```

最终，修正了坐标偏移后，效果如下图：

![](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/axial-diagram.png)
![](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/axial-coordinates.png)



至此，已经修复了X和Z两个轴向上的HexCel的坐标问题，在XZ坐标中，平面内所有的HexCel都可以使用一个正确的坐标来表示它们的位置，以及在XZ方向的运动和偏移。但是，六边形地图系统中存在一个比较特殊的情况，即每个正六边形是有六个方向的，这就需要将X轴水平反转，得到Y维度，如下图：

![Y维度](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/cube-diagram.png)

由于X和Y维度相互镜像，如果将Z保持不变，则将X和Y的坐标加在一起将始终产生相同的结果。实际上，如果将所有三个坐标加在一起，总会得到零。如果增加一个坐标，则必须减少另一个坐标。所以，这就产生了六个运动方向。这些坐标通常称为立方体坐标，因为它们是三维坐标，并且拓扑类似于立方体。
由于所有坐标的总和为零，因此始终可以从其他两个坐标导出每个坐标。由于之前已经存储了X和Z坐标，因此不需要存储Y坐标。可以在结构体HexCoordinates中包含一个新的属性，该属性通过计算可以得出Y坐标的值，并在结构体HexCoordinates的其他方法中使用。修改代码如下：

```csharp
    public int Y
    {
        get
        {
            return -X - Z;
        }
    }

    public override string ToString()
    {
        return "(" +
            X.ToString() + ", " + Y.ToString() + ", " + Z.ToString() + ")";
    }

    public string ToStringOnSeparateLines()
    {
        return X.ToString() + "\n" + Y.ToString() + "\n" + Z.ToString();
    }
```

添加Y坐标后的效果如下图：

![立方体坐标](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/cube-coordinates.png)

#### 7. Inspector中显示坐标
在Unity3D的Play模式下，选中一个生成的HexCell，在Inspector面板中只显示了coordinates这个变量的名字，而没有显示其坐标值：

![Inspector面板内容](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/inspector-empty-coordinates.png)

只显示变量名称而不显示其中数据，是因为没有将这个变量序列化，为此，需要将其中所包含的X Z坐标序列化，才可以在Inspector显示出来，修改HexCoordinates.cs脚本与Inspector面板显示结果如下：

```csharp
    [SerializeField]
    private int x, z;

    public int X
    {
        get
        {
            return x;
        }
    }

    public int Z
    {
        get
        {
            return z;
        }
    }

    public HexCoordinates(int x, int z)
    {
        this.x = x;
        this.z = z;
    }
```

![Inspector面板内容](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/inspector-editable-coordinates.png)

通过修改代码，X和Z坐标的数值已经可以显示在Inspector面板中。但是这样是可以修改其数值的显示方式，而且一般在Unity3D中显示坐标应该为(x, y, z)的形式。所以，需要修改坐标纸在Inspector面板中的显示外观样式。
在当前工程的Assets目录下新建Editor文件夹，并在Editor文件夹中创建HexCoordinatesDrawer脚本，同时需要将该脚本与其对应要重新绘制外观样式的脚本，通过代码想关联起来。代码如下：

```csharp
using UnityEngine;
using UnityEditor;

[CustomPropertyDrawer(typeof(HexCoordinates))]
public class HexCoordinatesDrawer : PropertyDrawer
{
}
```

在Unity3D中，所有的编辑器界面显示内容，均使用OnGUI方法进行绘制，此方法提供了要在其中绘制的矩形位置，属性的序列化数据以及它所属的字段的标签。从属性中提取x和z值，并使用这些值创建新的坐标集。然后使用HexCoordinates.ToString方法在指定位置绘制一个GUI标签。代码与运行效果如下

```csharp
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        HexCoordinates coordinates = new HexCoordinates(
            property.FindPropertyRelative("x").intValue, 
            property.FindPropertyRelative("z").intValue);

        GUI.Label(position, coordinates.ToString());
    }
```

![没有前缀标签的坐标](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/inspector-no-label.png)

这样虽然可以正确显示坐标数值，但是并没有前缀的标签，而且位置也不正确，这里需要使用EditorGUI.PrefixLabel来重新调整坐标文本的矩形位置，代码与运行结果如下图：

```csharp
        position = EditorGUI.PrefixLabel(position, label);
```

![带有前缀标签的坐标](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/inspector-with-label.png)

#### 8. 基础交互响应
至此，已经完成了地图网格的基本功能，但是目前地图并没有交互响应的功能，这也就意味着无法与玩家的动作产生交互。因此，需要在HexGrid.cs脚本中添加HexCell与玩家交互产生的反映。
在Unity3D中，一个GameObject要检测是否被鼠标或手指点击，是从点击处向场景中发射一个射线，射线被含有Collider的物体遮挡时，就会触发点击事件。对HexGrid.cs脚本修改如下

```csharp
    void Update()
    {
        if (Input.GetMouseButton(0))
        {
            HandleInput();
        }
    }

    void HandleInput()
    {
        Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        if (Physics.Raycast(inputRay, out hit))
        {
            TouchCell(hit.point);
        }
    }

    void TouchCell(Vector3 position)
    {
        position = transform.InverseTransformPoint(position);
        Debug.Log("touched at " + position);
    }
```

每个射线需要检测是否被Collider所遮挡，这里，需要在HexMesh物体上挂载Mesh Collider，通过程序生成了正六边形Mesh后，将Mesh数据传至Mesh Collider，使其可以生成碰撞器。HexMesh.cs脚本修改如下：

```csharp
    MeshCollider meshCollider;

    void Awake()
    {
        GetComponent<MeshFilter>().mesh = hexMesh = new Mesh();
        meshCollider = gameObject.AddComponent<MeshCollider>();
        …
    }

    public void Triangulate(HexCell[] cells)
    {
        …
        meshCollider.sharedMesh = hexMesh;
    }
```

这样，在Game视图中，点击生成的地图，就会显示当前点击的位置坐标。但是，还需要将当前鼠标点击的位置，转化为正六边形地图网格中的坐标位置，这个功能要在HexCoordinates结构体中实现。首先要在HexMesh.cs脚本中添加对方法的引用，HexMesh.cs脚本修改代码如下：

```csharp
    public void TouchCell(Vector3 position)
    {
        position = transform.InverseTransformPoint(position);
        HexCoordinates coordinates = HexCoordinates.FromPosition(position);
        Debug.Log("touched at " + coordinates.ToString());
    }
```

这样，当鼠标点击正六边形地图的时候，会在Console面板中显示出当前鼠标点击位置的坐标。但是，还需要将当前鼠标点击的位置坐标，对应到正六边形地图的坐标当中。其中正六边形网格的X坐标可以通过实际鼠标点击位置坐标除以正六边形地图块宽度获得。当Z为0时，Y与X互为镜像，则Y坐标的值与X坐标的值互为相反数。当X与Z坐标整体沿着Y产生偏移的时候，就需要将X与Z整体进行偏移。最后，将Z、Y、Z坐标进行四舍五入为整数，就可以得出最终的结果。代码如下：

```csharp
    public static HexCoordinates FromPosition(Vector3 position)
    {
        float x = position.x / (HexMetrics.innerRadius * 2f);
        float y = -x;

        float offset = position.z / (HexMetrics.outerRadius * 3f);
        x -= offset;
        y -= offset;

        int iX = Mathf.RoundToInt(x);
        int iY = Mathf.RoundToInt(y);
        int iZ = Mathf.RoundToInt(-x - y);

        return new HexCoordinates(iX, iZ);
    }
```

但是这种计算方式，最终在四舍五入的时候，可能会产生X、Y、Z之和部位0的情况，也就是在四舍五入时会产生误差。而且，鼠标点击位置距离一个正六边形地图块的重点越远，其四舍五入的误差越大，最终解决的方案是，舍弃具有最大舍入增量的坐标，并从其他两个坐标中重构它。代码如下：

```csharp
        if (iX + iY + iZ != 0)
        {
            float dX = Mathf.Abs(x - iX);
            float dY = Mathf.Abs(y - iY);
            float dZ = Mathf.Abs(-x - y - iZ);

            if (dX > dY && dX > dZ)
            {
                iX = -iY - iZ;
            }
            else if (dZ > dY)
            {
                iZ = -iX - iY;
            }
        }
```

#### 9. 点击改变颜色
现在，当鼠标点击的时候，就可以在Console面板中显示出当前点击的正六边形地图块的坐标了。但是这样并不直观，需要增加鼠标点击后，改变被点击的HexCell颜色的方法，在HexGrid.cs中添加两个变量，记录点击前和点击后颜色的值。代码如下：

```csharp
    public Color defaultColor = Color.white;
    public Color touchedColor = Color.magenta;
```

同时，需要在每个HexCell中记录自己的颜色值，HexCell也要同事添加一个记录颜色值的变量。代码如下：

```csharp
    public Color color;
```

在HexGrid.cs创建六边形的时候，同时要为每个六边形赋颜色值。在HexGrid.CreateCell方法中添加赋值颜色初始值语句。代码如下：

```csharp
        cell.color = defaultColor;
```

然后，在HexMesh创建六边形网格的时候，需要将每个HexCell的颜色值保存下来，并且在重新计算法线之前先赋值颜色值。HexMesh.cs代码修改如下：

```csharp
List<Color> colors;

void Awake()
{
    …
    colors = new List<Color>();
    …
}

public void Triangulate(HexCell[] cells)
{
    colors.Clear();
    …
    hexMesh.colors = colors.ToArray();
    …
}
```

在之前Triangulate方法中，依次取出正六边形两个顶点，加上中点组成一个三角形。每次取出的时候记录了顶点位置信息，这里还要增加记录顶点颜色信息的代码。修改代码如下：

```csharp
    void Triangulate(HexCell cell)
    {
        for (int i = 0; i < 6; i++)
        {
            …
            AddTriangleColor(cell.color);
        }
    }

    void AddTriangleColor(Color color)
    {
        colors.Add(color);
        colors.Add(color);
        colors.Add(color);
    }
```

现在返回HexGrid.TouchCell方法，当鼠标点击到正六边形上时候，通过已知的坐标换算为数组中的索引，这样就可以知道鼠标点击到哪个HexCell上了。最后再改变这个HexCell的颜色，得到鼠标点击后的响应效果。代码如下：

```csharp
    private void TouchCell(Vector3 position)
    {
        …
        int index = coordinates.X + coordinates.Z * width + coordinates.Z / 2;
        HexCell cell = cells[index];
        cell.color = touchedColor;
        hexMesh.Triangulate(cells);
        …
    }
```

最后，HexMesh所使用的默认Shader并不是使用顶点着色，这里需要创建一个自定义Shader，并修改其代码为顶点着色。这个Shader只需要两处修改。第一，将颜色数据添加到其输入结构体中。第二，将反照率乘以该颜色。这里只使用不透明材质，所以只需要关注RGB通道即可。代码与运行效果如下：

```csharp
Shader "Custom/VertexColors" {
	Properties{
		_Color("Color", Color) = (1,1,1,1)
		_MainTex("Albedo (RGB)", 2D) = "white" {}
		_Glossiness("Smoothness", Range(0,1)) = 0.5
		_Metallic("Metallic", Range(0,1)) = 0.0
	}
		SubShader{
			Tags { "RenderType" = "Opaque" }
			LOD 200

			CGPROGRAM
			#pragma surface surf Standard fullforwardshadows
			#pragma target 3.0

			sampler2D _MainTex;

			struct Input {
				float2 uv_MainTex;
				float4 color : COLOR;
			};

			half _Glossiness;
			half _Metallic;
			fixed4 _Color;

			void surf(Input IN, inout SurfaceOutputStandard o) {
				fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
				o.Albedo = c.rgb * IN.color;
				o.Metallic = _Metallic;
				o.Smoothness = _Glossiness;
				o.Alpha = c.a;
			}
			ENDCG
		}
			FallBack "Diffuse"
}
```

![被点击的HexCell改变颜色](https://catlikecoding.com/unity/tutorials/hex-map/part-1/interaction/colored-cells.png)

#### 10. 简单地图编辑器
目前，玩家已经可以通过点击鼠标来完成与地图系统的最基本的交互。接下来要完成基础的游戏内地图编辑器系统，所以要对目前的代码作出一些修改。在HexGrid.cs脚本内，删除touchedColor字段，同时修改TouchCell为带有Color参数的方法。代码如下：

```csharp
    public void ColorCell(Vector3 position, Color color)
    {
        position = transform.InverseTransformPoint(position);
        HexCoordinates coordinates = HexCoordinates.FromPosition(position);

        int index = coordinates.X + coordinates.Z * width + coordinates.Z / 2;
        HexCell cell = cells[index];
        cell.color = color;
        hexMesh.Triangulate(cells);
    }
```

新建脚本HexMapEditor.cs，这个脚本目前将负责存储多个颜色值，并将其赋值到不同的HexCell上。首先，要将HexGrid中的Update、HandleInput方法移动到HexMapEditor.cs中，接着创建一个引用HexGrid的公共变量。最后，创建一个颜色变量，来存储当前激活的颜色的值。代码如下：

```csharp
using UnityEngine;

public class HexMapEditor : MonoBehaviour
{
    public Color[] colors;

    public HexGrid hexGrid;

    private Color activeColor;

    void Awake()
    {
        SelectColor(0);
    }

    void Update()
    {
        if (Input.GetMouseButton(0))
        {
            HandleInput();
        }
    }

    void HandleInput()
    {
        Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        if (Physics.Raycast(inputRay, out hit))
        {
            hexGrid.ColorCell(hit.point, activeColor);
        }
    }

    public void SelectColor(int index)
    {
        activeColor = colors[index];
    }
}
```

HexMapEditor.cs脚本完成后，在场景中新建Canvas，保存吃其所有组件属性为默认，挂载HexMapEditor.cs.cs脚本，并在Inspector面板的colors数组进行初始化并赋值。结构如下图：

![新建Canvas](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/canvas.png)

接着，需要在新建Canvas下创建一组复选按钮组，用来选择鼠标点击后，正六边形所改变的颜色。通过GameObject / UI / Panel创建一个Panel作为单选按钮组的容器，将其调整至屏幕左上角，添加Toggle Group组件，Toggle Group组件可以让引用它的单选按钮自动成为一组。参数设置如下图：

![Panel参数设置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/panel-toggle-group.png)

在Panel下创建4个单选按钮，分别对应了HexMapEditor中的4个颜色。外观样式与文件结构如下图：

![单选按钮组外观样式](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/ui.png)
![单选按钮组层级结构](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/hierarchy.png)

四个单选按钮创建完成后，在其Toggle组件中，将Toggle Group的引用添加至Group变量中。四个单选按钮同时引用了Toggle Group组件，这样就实现了每次只有一种颜色被勾选的效果。
在单选按钮的Toggle组件中，每次组件值的改变，均会触发On Vaule Changed(Boolean)事件，这里事件回调需要执行HexMapEditor.SelectColor方法。点击On Vaule Changed(Boolean)面板右下角“+”，引用HexMapEditor.cs脚本，并找到SelectColor方法。其中传入参数依次从0到3。Toggle组件参数设置如下图：

![Toggle组件参数设置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/toggle.png)

这样，就实现了，选择不同颜色，然后通过鼠标左键点击，让被点击的正六边形地图块显示不同的颜色的功能。不过，当鼠标点击任意一个正六边形地图块的时候，鼠标UI和正六边形地图块Mesh会同时做出响应，这样会造成逻辑和事件处理的混乱，所以，需要将这两个事件分别处理。这里使用Unity3D中EventSystems类监听鼠标是否悬停在UI上进行判断，HexMapEditor修改代码如下：

```csharp
using UnityEngine.EventSystems;

        …

    void Update()
    {
        if (Input.GetMouseButton(0) && !EventSystem.current.IsPointerOverGameObject())
        {
            HandleInput();
        }
    }
```

#### 11. 获取相邻的单元格
现在，正六边形地图已经可以响应鼠标的点击并按照UI中选中的颜色进行着色，而且可以获取到自身的坐标位置。但是当两个相邻的正六边形地图块颜色不同的时候，之间的过渡会显得格外生硬，所以需要将相邻的正六边形地图块两者的颜色，在接触的边界上进行混合。使两个相邻的正六边形地图块颜色过渡更加平滑。
进行颜色混合的第一部，是要获取每个正六边形地图块相邻的六个地图块。这里使用罗盘方向来识别它们。方向分别为东北、东、东南、西南、西、西北。示意如下图：

![相邻的六边形地图块](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/directions.png)

为了标记每个相邻的正六边形地图块的方位，最简便的方法就是使用枚举，创建HexDirection脚本，代码如下：

```csharp
public enum HexDirection
{
    NE,
    E,
    SE,
    SW,
    W,
    NW
}
```

接下来，需要在HexCell.cs脚本中添加一个数组，用来存储这个正六边形地图块周围六个相邻的地图块的实例。HexCell添加代码如下：

```csharp
    [SerializeField] private HexCell[] neighbors;
```

这样，选中HexCell Prefab后，在Inspector面板中，就可以看到neighbors数组了。这里需要将该数组的初始长度调整为6，用来存储相邻的正六边形地图块。如下图：

![neighbors初始长度为6](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/prefab.png)

数组长度设置完成后，需要在HexCell.cs脚本中继续添加为该数组中每个元素赋值(Set)和获取实例(Get)的方法。在赋值方法中，由于每个正六边形地图块相邻的只有六个地图块，不用关注索引越界的问题，所以不用验证。代码如下：

```csharp
    public HexCell GetNeighbor(HexDirection direction)
    {
        return neighbors[(int)direction];
    }

    public void SetNeighbor(HexDirection direction, HexCell cell)
    {
        neighbors[(int)direction] = cell;
    }
```

为了增加效率，减少遍历次数，在当前地图块添加其相邻地图块的时候，同时也将自身添加到相邻地图块的neighbors数组中，并同时计算其相对位置。如下图

![两个相邻正六边形地图块的相对位置](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/bidirectional.png)

在HexDirection.cs脚本中添加Opposite方法，在SetNeighbor方法执行时候进行调用。Opposite是用来计算当前地图块与其相邻地图块相对位置的方法。如果其相邻地图块枚举值小于3，则当前地图块枚举值要+3，反之，当前相邻地图块枚举值大于3，则当前地图块枚举值要-3。HexDirection.cs与HexCell.cs脚本如下：

```csharp
public static class HexDirectionExtensions
{
    public static HexDirection Opposite(this HexDirection direction)
    {

        if ((int)direction < 3)
        {
            return (direction + 3);
        }
        else
        {
            return (direction - 3);
        }
    }
}
```

```csharp
    public void SetNeighbor(HexDirection direction, HexCell cell)
    {
        neighbors[(int)direction] = cell;
        cell.neighbors[(int)direction.Opposite()] = this;
    }
```

#### 12. 链接相邻的单元格
添加相邻地图块的方法已经完成，接下来需要在地图块创建的时候为每个地图块中的数组赋值。各个地图块之间的链接关系，最简单的是W方位链接，但是这里需要注意一点，并非每个地图块都有完整的六个相邻的地图块。在边界处的地图块，与其相邻的地图块数量至少为2个，至多为5个。下图中使用数字来标记出了每个地图块有相邻地图块的数量：

![每个地图块相邻的地图块数量](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/neighbor-count.png)

通过观察上图可以发现，在最左侧的正六边形地图块，是没有W方位相邻地图块的。在HexGrid.CreateCell方法创建六边形地图快实例时，判断当前地图块是不是最左侧的一个，并建立W方位链接。示意图和代码修改如下：

![每个单元格W的链接关系](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/neighbors-e-w.png)

```csharp
    void CreateCell (int x, int z, int i) {
        …
        cell.color = defaultColor;

        if (x > 0)
        {
            cell.SetNeighbor(HexDirection.W, cells[i - 1]);
        }

        Text label = Instantiate<Text>(cellLabelPrefab);
        …
	}
```

接下来是创建SE链接，通过观察正六边形地图网格可以发现，地图网格中除了第一行的的偶数行，每一个地图块必有SE方位相位的地图块。首先判断地图块所在行是否为除第0行的偶数行，然后找到其上一行，并定位与之相邻的SE方位的地图块。示意图与代码如下：

![每个单元格SE的链接关系](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/neighbors-even-nw-se.png)

```csharp
        if (z > 0)
        {
            if ((z & 1) == 0)
            {
                cell.SetNeighbor(HexDirection.SE, cells[i - width]);
            }
        }
```

SW方位的连接关系与SE相类似，在除了第0行的偶数行中，每行第一个地图块是没有SW方位相邻的地图块。其他位置与SE方位链接类似，示意图与代码如下

![每个单元格SW的链接关系](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/neighbors-even-ne-sw.png)

```csharp
        if (z > 0)
        {
            if ((z & 1) == 0)
            {
                cell.SetNeighbor(HexDirection.SE, cells[i - width]);

                if (x > 0)
                {
                    cell.SetNeighbor(HexDirection.SW, cells[i - width - 1]);
                }
            }
        }
```

最后，其他未做判断的行中的地图块基本与之前的地图块逻辑相同，只不过其位置是镜像的，添加镜像的代码使其获得相邻地图块的链接。这样，所有的地图块与其相邻的地图块就建立了完整的方位链接，为下一步进行颜色混合做好了准备。修改代码与完成示意图如下：

```csharp
            else
            {
                cell.SetNeighbor(HexDirection.SW, cells[i - width]);
                if (x < width - 1)
                {
                    cell.SetNeighbor(HexDirection.SE, cells[i - width + 1]);
                }
            }
```

![所有相邻地图块都已链接](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/all-connected.png)

#### 13. 拆分正六边形地图块
混合色彩的下一步，要将每个正六边形地图块进行拆分。因为现在每个正六边形地图块只能进行单一颜色的着色，也就是所有顶点的颜色都相同。而颜色混合是要将每个正六边形地图块不同的顶点赋值不同的颜色。现在使用HexDirection中的方位来标识每一个正六边形地图块中的各个顶点。这一步在HexMesh.cs的Triangulate方法创建正六边形地图块时执行，修改代码如下：

```csharp
    void Triangulate(HexCell cell)
    {
        for (HexDirection d = HexDirection.NE; d <= HexDirection.NW; d++)
        {
            Triangulate(d, cell);
        }
    }

    private void Triangulate(HexDirection direction, HexCell cell)
    {
        Vector3 center = cell.transform.localPosition;

        for (int i = 0; i < 6; i++)
        {
            AddTriangle(
                center,
                center + HexMetrics.corners[(int)direction],
                center + HexMetrics.corners[(int)direction + 1]
            );

            AddTriangleColor(cell.color);
        }
    }
```
这样就酱每个顶点赋值了方位属性，但是这里在添加顶点时，还是用到了数字索引，并没有完全实现使用方位进行赋值，所以，要修改HexMetrics.cs，在其中加入获取第一个顶点方位和下一个顶点方位的静态方法。HexMetrics.cs与HexMesh.cs修改如下

```csharp
    public static Vector3 GetFirstCorner(HexDirection direction)
    {
        return corners[(int)direction];
    }

    public static Vector3 GetSecondCorner(HexDirection direction)
    {
        return corners[(int)direction + 1];
    }
```

```csharp
            AddTriangle(
                center,
                center + HexMetrics.GetFirstCorner(direction),
                center + HexMetrics.GetSecondCorner(direction)
            );
```

#### 14. 拆分正六边形地图块








![]()

```csharp

```