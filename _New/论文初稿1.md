#### 前言
当今，许多的主流策略类型的游戏都在使用网格地图(HexGrid)，其中包括《奇迹时代3》、《文明6》、《无尽传奇》、《英雄无敌》等著名的3A游戏。网格地图具有生成快速、完全程序化控制、易于解析和存储等优势，相比于用传统美术等方式制作游戏地图，对移动端设备更加友好，可以大幅度减少美术资源数量，安装包更小，更容易被用户接受。

Unity3D是由Unity Technologies开发的一个让玩家轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合型游戏开发工具，是一个全面整合的专业游戏引擎。Unity类似于Director,Blender game engine, Virtools 或 Torque Game Builder等利用交互的图型化开发环境为首要方式的软件。其编辑器可运行在Windows、Linux、Mac OS X下，可发布游戏至Windows、Mac、Wii、iPhone、WebGL、Android等多种类型的平台上。



#### 1. HexMap形状
在传统的回合制游戏中，尤其是日式RPG游戏，大多使用正方形网格地图。
在大多数回合策略游戏中，使用对网格地图通常有两种：正方形和正六边形。目前，越来越多的游戏已经逐渐从正方形转变到了正六边形。

为什么使用六边形的网格地图？在传统游戏中，尤其是传统的日式RPG中，大量的使用了正方形的网格地图。正方形网格相比其他形状，更容易绘制和定位。但是正方形网格也有明显的缺点，下图为一个正方形网格：

![一个正方形网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/square-grid.png)

中间这个正方形网格中，一共有8个与其相邻的网格。与中间正方形网格边相邻的网格，称为水平和垂直相邻，与中间正方形网格对角相邻的网格，称为对角相邻。
从上图中可以看出，如果每个正方形网格的边长为1，那么，水平和垂直相邻的正方形网格中点之间的距离也为1.但是，对角相邻的正方形网格中点之间的距离，为$\sqrt{ 2 }$。
两种形式的相邻网格，造成了距离的差异化。在游戏中，如果一个人物在正方形网格中进行移动，这种距离的差异化将会更加明显。为了避免这种差异化，不同的游戏使用了不同的方法，也有不同的有点和缺点。其中一种方法，就是使用正六边形网格代替传统的正方形网格。

![六边形网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/hexagon-grid.png)

与正方形网格相比，在正六边形网格中，每个地图块之间中点的距离都是相等的，这样就避免了距离的差异化。当然，使用正六边形网格也会有其他的问题，不过相对于距离差异化更容易解决。

![六边形的内外半径](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/hexagon.png)

在开始设计正六边形网格地图之前，必须先确定每个正六边形地图块的边长。如果一个正六边形地图块的边长为10，那么，这个正六边形地图块的外接圆半径也是10。
每个正六边形网格还有一个内切圆，根据勾股定理可以得出，其内切圆的半径为 $\frac{ \sqrt{ 3 } }{ 2 }$ 倍的边长，得出内切圆半径为 $5\sqrt{ 3 }$。
接下来，将这两个常量保存至一个静态类中，便于访问。代码如下：

```csharp
using UnityEngine;

public static class HexMetrics
{
    public const float outerRadius = 10f;

    public const float innerRadius = outerRadius * 0.866025404f;
}
```

确定了整列变形地图块的外接圆和内切圆半径后，接下来需要确定正六边形网格中，每个正六边形地图块的摆放姿态。
在正六边形网格中，每个正六边形地图块会有两种摆放姿态，顶点朝上或者边朝上。

![正六边形地图块的摆放姿态](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/orientations.png)

为了方便计算与排列，这里选择顶点朝上的排列方式，并将正六边形网格放置在XZ平面上。从正六边形地图块正上方一个顶点的位置开始，顺时针排列一个其相邻的六个地图块。以下代码为记录每个正六边形地图块其六个顶点位置：

```csharp
    public static Vector3[] corners =
    {
        new Vector3(0f, 0f, outerRadius),
        new Vector3(innerRadius, 0f, 0.5f * outerRadius),
        new Vector3(innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(0f, 0f, -outerRadius),
        new Vector3(-innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(-innerRadius, 0f, 0.5f * outerRadius)
    };
```

#### 2. 创建地图网格
要创建一个正六边形网格，需要先创建单个的正六边形地图块。在Unity3D中，可以将一个正六边形地图块制作为Prefab，方便程序引用和统一修改。讲每个正六边形地图块称为HexCell，并串讲基础脚本：

```csharp
using UnityEngine;

public class HexCell : MonoBehaviour
{
}
```

创建正六边形地图块Prefab非常简单，首先，在场景中创建一个Plane，并挂载HexCell.cs脚本，然后将其转换成Prefab，结果如下图：

![使用plane作为HexCell Prefab](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/hex-cell-plane.png)

接下来，要创建一个容器，用来实例化正六边形地图块，并将每个地图块有序的排列起来。其名称为HexGrid。脚本与参数如下图：

```csharp
using UnityEngine;

public class HexGrid : MonoBehaviour
{
    public int width = 6;
    public int height = 6;

    public HexCell cellPrefab;
}
```

![HexGrid 属性](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/hex-grid.png)

由于HexCell使用了Plane网格，Plane网格默认为 10x10 单位长度，所以在实例化HexCell时，需要加上边长的偏移量。实例化HexCell代码与生成无缝单元网格效果如下：

```csharp
    private HexCell[] cells;

    void Awake()
    {
        cells = new HexCell[height * width];

        for (int z = 0, i = 0; z < height; z++)
        {
            for (int x = 0; x < width; x++)
            {
                CreateCell(x, z, i++);
            }
        }
    }

    void CreateCell(int x, int z, int i)
    {
        Vector3 position;
        position.x = x * 10f;
        position.y = 0f;
        position.z = z * 10f;

        HexCell cell = Instantiate<HexCell>(cellPrefab);
        cells[i] = cell;

        cell.transform.SetParent(transform, false);
        cell.transform.localPosition = position;
    }
```

![生成的无缝单元网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/square-grid-of-planes.png)

虽然按照程序生成了相应网格，但是在程序调试过程中无法判断每个HexCell的位置，如果HexCell为正六边形，这个问题将会更加棘手。

#### 3. 显示坐标
要显示每个HexCell的坐标，可以使用Unity3D的UGUI系统来实现。创建一个Canvas，并将其设置为HexGrid的子物体。因为目前功能只需要显示坐标，不需要任何触发，所以删除Canvas上的Graphic Raycaster组件。下图为HexGridCanvas参数设置：

![HexGridCanvas参数设置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/canvas.png)

在Unity3D UGUI中，Canvas是承载UI元素的容器，要显示每个HexCell的坐标，需要在Canvas容器中创建一个Text对象，并将这个Text对象转换为Prefab。Text对象的参数设置如下图：

![Text对象参数设置 1](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/label-part-1.png)
![Text对象参数设置 2](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/label-part-2.png)

接下来，要在初始化HexCell时，同时初始化HexCellLabel，并且让每一个HexCellLabel与HexCell对齐，修改HexGrid.cs脚本与运行效果如下：
```csharp
using UnityEngine.UI;

    public Text cellLabelPrefab;

    Canvas gridCanvas;

    void Awake ()
    {
    gridCanvas = GetComponentInChildren<Canvas>();

        …
    }

    void CreateCell (int x, int z, int i)
    {
        …

        Text label = Instantiate<Text>(cellLabelPrefab);
        label.rectTransform.SetParent(gridCanvas.transform, false);
        label.rectTransform.anchoredPosition = new Vector2(position.x, position.z);
        label.text = x.ToString() + "\n" + z.ToString();
    }
```
![显示地图块的坐标](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/grid-with-labels.png)

#### 4. 设置地图块的位置
当前实例化的底图块为正方形而不是正六边形，如果要显示为正六边形地图块，需要修改每一个HexCell实例的位置，如下图所示，横向的两个正六边形地图块中点之间的距离为内切圆半径的2倍，纵向的两个正六边形地图块中点之间的距离，为外接圆半径的1.5倍。修改HexGrid.cs中CreateCell方法，使实例化每一个HexCellLabel与HexCell时，都出现在正确的位置。

![正六边形地图块的位置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/neighbor-distances.png)

```csharp
        position.x = x * (HexMetrics.innerRadius * 2f);
        position.y = 0f;
        position.z = z * (HexMetrics.outerRadius * 1.5f);
```

注意，正方形地图块的排列方式与正六边形地图块的排列方式还有一处不同，就是上下两排六边形地图块并不是位于彼此的正上方或正下方，而是彼此中点横向相差了内切圆半径的距离，所以，在HexGrid.cs的CreateCell方法中，需要增加这个偏移量，代码与运行效果图如下：

```csharp
        position.x = x * (HexMetrics.innerRadius * 2f) + z * HexMetrics.innerRadius;
```

![错开的地图块排列方式](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/rhombus.png)

现在，生成的地图网格整体为菱形，但是，在一般游戏中，使用矩形的地图网格会更加方便。所以，需要将偶数行地图块整体取消偏移量，修改HexGrid.cs的CreateCell方法，代码与运行结果如下所示：

```csharp
        position.x = (x + z * 0.5f - z / 2) * (HexMetrics.innerRadius * 2f);
```

![整体为正方形的地图网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/rectangular-area.png)

#### 5. 渲染正六边形地图块
每个地图块位置确定后，需要将目前的正方形地图块修改为正六边形地图块。首先需要删除HexCell Prefab上的Mesh Filter、Mesh Renderer、Mesh Collider组件，这样在实例化HexCell的时候就不会出现默认的正方形图案。如下图：

![修改后的HexCell Prefab](https://catlikecoding.com/unity/tutorials/hex-map/part-1/rendering-hexagons/empty-cell-prefab.png)

接下来，需要两个链表来记录所有正六边形中每个顶点与三角面片，创建HexMesh.cs脚本，新建一个GameOnject作为HexGrid的子物体，命名为HexMesh，并挂载HexMesh.cs脚本。HexMesh.cs代码及HexMesh参数配置如下：

```csharp
using UnityEngine;
using System.Collections.Generic;

[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class HexMesh : MonoBehaviour
{
    Mesh hexMesh;
    List<Vector3> vertices;
    List<int> triangles;

    void Awake()
    {
        GetComponent<MeshFilter>().mesh = hexMesh = new Mesh();
        hexMesh.name = "Hex Mesh";
        vertices = new List<Vector3>();
        triangles = new List<int>();
    }
}
```
![HexMesh参数配置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/rendering-hexagons/hex-mesh.png)

这样，HexGrid.cs脚本在初始化时，就可以引用HexMesh.cs进行网格的绘制，修改HexGrid.cs脚本如下

```csharp
    HexMesh hexMesh;

    void Awake()
    {
        gridCanvas = GetComponentInChildren<Canvas>();
        hexMesh = GetComponentInChildren<HexMesh>();

        …
    }
```

在Unity3D中，当所有脚本的Awake方法执行完毕后，才会执行每个脚本的Start方法，所以，确保HexMesh.cs初始化完成后，在HexGrid.cs脚本的Start方法中调用HexMesh.cs的网格绘制方法，在HexGrid.cs中添加的代码如下：

```csharp
void Start ()
    {
        hexMesh.Triangulate(cells);
    }
```

接下来，需要完成HexMesh.Triangulate方法，此方法主要先将之前可能残留在链表中的数据清除，之后获取当前的正六边形中点坐标，根据中点坐标绘制正六边形。接下来，将绘制完成的正六边形的顶点和三角面片信息，分别存储在两个链表中。最后，要根据生成的顶点与三角面片的信息，重新计算法线，保证视觉效果的正确性。

```csharp
    public void Triangulate(HexCell[] cells)
    {
        hexMesh.Clear();
        vertices.Clear();
        triangles.Clear();
        for (int i = 0; i < cells.Length; i++)
        {
            Triangulate(cells[i]);
        }
        hexMesh.vertices = vertices.ToArray();
        hexMesh.triangles = triangles.ToArray();
        hexMesh.RecalculateNormals();
    }

    void Triangulate(HexCell cell)
    {
    }
```

正六边形是由6个等边三角形面片构成的，在Unity3D中，会按照每3个一组的顶点位置信息来绘制三角面片。所以，每次以三个一组的数据绘制三角面片之前，分别将顶点信息和三角面片顺序信息存储在链表中。HexMesh.cs添加的代码如下：

```csharp
    void AddTriangle(Vector3 v1, Vector3 v2, Vector3 v3)
    {
        int vertexIndex = vertices.Count;
        vertices.Add(v1);
        vertices.Add(v2);
        vertices.Add(v3);
        triangles.Add(vertexIndex);
        triangles.Add(vertexIndex + 1);
        triangles.Add(vertexIndex + 2);
    }
```

正六边形中的每个顶点相对其中点的位置信息，都保存在HexMetrics类中，通过正六边形的中点位置，可以计算得出其6个顶点的位置，除了中点之外，从正上方顶点开始，每次取出两个相邻的顶点，进行三角面片的绘制。Triangulate重载方法的修改如下：

```csharp
    void Triangulate(HexCell cell)
    {
        Vector3 center = cell.transform.localPosition;

        for (int i = 0; i < 6; i++)
        {
            AddTriangle(
                center,
                center + HexMetrics.corners[i],
                center + HexMetrics.corners[i+1]
            );
        }
    }
```

注意，在以上循环加载整六边形顶点时，初始顶点和结束顶点位置相同，但是索引不同，需要在HexMetrics的corners数组中增加一个结束元素，否则循环到最后一个顶点的时候将会造成数组越界，修改corners数组代码如下：

```csharp
    public static Vector3[] corners =
    {
        new Vector3(0f, 0f, outerRadius),
        new Vector3(innerRadius, 0f, 0.5f * outerRadius),
        new Vector3(innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(0f, 0f, -outerRadius),
        new Vector3(-innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(-innerRadius, 0f, 0.5f * outerRadius),
        new Vector3(0f, 0f, outerRadius)
    };
```

最终运行效果如下图：

![完成效果](https://catlikecoding.com/unity/tutorials/hex-map/part-1/rendering-hexagons/complete-hexagons.png)

#### 6. 修正地图坐标
完成基本的正六边形绘制后，每个正六边形元素在Z轴方向上，坐标都很正常。但是在X轴方向上，所有的正六边形坐标都呈现锯齿状。这是为了填充每个正六边形之间空隙所产生的副作用，如下图所示：

![整六边形排列](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/offset-diagram.png)

这些偏移导致了在处理X坐标的时候会有些繁琐。在这里，需要一添加一个新的类，重新转换这些HexCell的坐标，使其更容易序列化，便于存储。并且在程序运行时，这些坐标数据不会被重新编译，保证了程序的运行效率。新建脚本HexCoordinates.cs，其中FromOffsetCoordinates静态方法负责将现有的坐标逐个读取进行转换，并返回转换后的新坐标。代码如下：

```csharp
using UnityEngine;
using System;

[Serializable]
public struct HexCoordinates
{
    public int X { get; private set; }

    public int Z { get; private set; }

    public HexCoordinates(int x, int z)
    {
        X = x;
        Z = z;
    }

    public static HexCoordinates FromOffsetCoordinates(int x, int z)
    {
        return new HexCoordinates(x, z);
    }
}
```

为了更加方便地显示坐标数值，这里要重写ToString方法。因为原有的ToString方法只会显示方法名或者结构体名，这里需要在一行中直接输出X与Z的坐标值，同时再添加一个X与Z的坐标值分别在单独行显示的方法。代码如下：

```csharp
    public override string ToString()
    {
        return "(" + X.ToString() + ", " + Z.ToString() + ")";
    }

    public string ToStringOnSeparateLines()
    {
        return X.ToString() + "\n" + Z.ToString();
    }
```

接下来，在HexCell.cs初始化的时候，就可以使用HexCoordinates进行坐标的记录、转换和输出了。HexCell.cs代码修改如下：

```csharp
public class HexCell : MonoBehaviour
{
    public HexCoordinates coordinates;
}
```

在HexGrid.cs创建正HexCell的时候，就可以直接调用HexCoordinates结构体中的方法输出当前HexCell的坐标值了，HexGrid.cs中CreateCell方法添加如下代码：

```csharp
        cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);
        label.text = cell.coordinates.ToStringOnSeparateLines();
```

然后，就可以很方便的在结构体HexCoordinates的FromOffsetCoordinates方法中调整HexCell的坐标了。为了抵消X方向的偏移，修改其代码如下：

```csharp
    public static HexCoordinates FromOffsetCoordinates(int x, int z)
    {
        return new HexCoordinates(x - z / 2, z);
    }
```

最终，修正了坐标偏移后，效果如下图：

![](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/axial-diagram.png)
![](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/axial-coordinates.png)



至此，已经修复了X和Z两个轴向上的HexCel的坐标问题，在XZ坐标中，平面内所有的HexCel都可以使用一个正确的坐标来表示它们的位置，以及在XZ方向的运动和偏移。但是，六边形地图系统中存在一个比较特殊的情况，即每个正六边形是有六个方向的，这就需要将X轴水平反转，得到Y维度，如下图：

![Y维度](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/cube-diagram.png)

由于X和Y维度相互镜像，如果将Z保持不变，则将X和Y的坐标加在一起将始终产生相同的结果。实际上，如果将所有三个坐标加在一起，总会得到零。如果增加一个坐标，则必须减少另一个坐标。所以，这就产生了六个运动方向。这些坐标通常称为立方体坐标，因为它们是三维坐标，并且拓扑类似于立方体。
由于所有坐标的总和为零，因此始终可以从其他两个坐标导出每个坐标。由于之前已经存储了X和Z坐标，因此不需要存储Y坐标。可以在结构体HexCoordinates中包含一个新的属性，该属性通过计算可以得出Y坐标的值，并在结构体HexCoordinates的其他方法中使用。修改代码如下：

```csharp
    public int Y
    {
        get
        {
            return -X - Z;
        }
    }

    public override string ToString()
    {
        return "(" +
            X.ToString() + ", " + Y.ToString() + ", " + Z.ToString() + ")";
    }

    public string ToStringOnSeparateLines()
    {
        return X.ToString() + "\n" + Y.ToString() + "\n" + Z.ToString();
    }
```

添加Y坐标后的效果如下图：

![立方体坐标](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/cube-coordinates.png)

#### 7. Inspector中显示坐标
在Unity3D的Play模式下，选中一个生成的HexCell，在Inspector面板中只显示了coordinates这个变量的名字，而没有显示其坐标值：

![Inspector面板内容](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/inspector-empty-coordinates.png)

只显示变量名称而不显示其中数据，是因为没有将这个变量序列化，为此，需要将其中所包含的X Z坐标序列化，才可以在Inspector显示出来，修改HexCoordinates.cs脚本与Inspector面板显示结果如下：

```csharp
    [SerializeField]
    private int x, z;

    public int X
    {
        get
        {
            return x;
        }
    }

    public int Z
    {
        get
        {
            return z;
        }
    }

    public HexCoordinates(int x, int z)
    {
        this.x = x;
        this.z = z;
    }
```

![Inspector面板内容](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/inspector-editable-coordinates.png)

通过修改代码，X和Z坐标的数值已经可以显示在Inspector面板中。但是这样是可以修改其数值的显示方式，而且一般在Unity3D中显示坐标应该为(x, y, z)的形式。所以，需要修改坐标纸在Inspector面板中的显示外观样式。
在当前工程的Assets目录下新建Editor文件夹，并在Editor文件夹中创建HexCoordinatesDrawer脚本，同时需要将该脚本与其对应要重新绘制外观样式的脚本，通过代码想关联起来。代码如下：

```csharp
using UnityEngine;
using UnityEditor;

[CustomPropertyDrawer(typeof(HexCoordinates))]
public class HexCoordinatesDrawer : PropertyDrawer
{
}
```

在Unity3D中，所有的编辑器界面显示内容，均使用OnGUI方法进行绘制，此方法提供了要在其中绘制的矩形位置，属性的序列化数据以及它所属的字段的标签。从属性中提取x和z值，并使用这些值创建新的坐标集。然后使用HexCoordinates.ToString方法在指定位置绘制一个GUI标签。代码与运行效果如下

```csharp
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        HexCoordinates coordinates = new HexCoordinates(
            property.FindPropertyRelative("x").intValue, 
            property.FindPropertyRelative("z").intValue);

        GUI.Label(position, coordinates.ToString());
    }
```

![没有前缀标签的坐标](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/inspector-no-label.png)

这样虽然可以正确显示坐标数值，但是并没有前缀的标签，而且位置也不正确，这里需要使用EditorGUI.PrefixLabel来重新调整坐标文本的矩形位置，代码与运行结果如下图：

```csharp
        position = EditorGUI.PrefixLabel(position, label);
```

![带有前缀标签的坐标](https://catlikecoding.com/unity/tutorials/hex-map/part-1/hexagonal-coordinates/inspector-with-label.png)

#### 8. 基础交互响应
至此，已经完成了地图网格的基本功能，但是目前地图并没有交互响应的功能，这也就意味着无法与玩家的动作产生交互。因此，需要在HexGrid.cs脚本中添加HexCell与玩家交互产生的反映。
在Unity3D中，一个GameObject要检测是否被鼠标或手指点击，是从点击处向场景中发射一个射线，射线被含有Collider的物体遮挡时，就会触发点击事件。对HexGrid.cs脚本修改如下

```csharp
    void Update()
    {
        if (Input.GetMouseButton(0))
        {
            HandleInput();
        }
    }

    void HandleInput()
    {
        Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        if (Physics.Raycast(inputRay, out hit))
        {
            TouchCell(hit.point);
        }
    }

    void TouchCell(Vector3 position)
    {
        position = transform.InverseTransformPoint(position);
        Debug.Log("touched at " + position);
    }
```

每个射线需要检测是否被Collider所遮挡，这里，需要在HexMesh物体上挂载Mesh Collider，通过程序生成了正六边形Mesh后，将Mesh数据传至Mesh Collider，使其可以生成碰撞器。HexMesh.cs脚本修改如下：

```csharp
    MeshCollider meshCollider;

    void Awake()
    {
        GetComponent<MeshFilter>().mesh = hexMesh = new Mesh();
        meshCollider = gameObject.AddComponent<MeshCollider>();
        …
    }

    public void Triangulate(HexCell[] cells)
    {
        …
        meshCollider.sharedMesh = hexMesh;
    }
```

这样，在Game视图中，点击生成的地图，就会显示当前点击的位置坐标。但是，还需要将当前鼠标点击的位置，转化为正六边形地图网格中的坐标位置，这个功能要在HexCoordinates结构体中实现。首先要在HexMesh.cs脚本中添加对方法的引用，HexMesh.cs脚本修改代码如下：

```csharp
    public void TouchCell(Vector3 position)
    {
        position = transform.InverseTransformPoint(position);
        HexCoordinates coordinates = HexCoordinates.FromPosition(position);
        Debug.Log("touched at " + coordinates.ToString());
    }
```

这样，当鼠标点击正六边形地图的时候，会在Console面板中显示出当前鼠标点击位置的坐标。但是，还需要将当前鼠标点击的位置坐标，对应到正六边形地图的坐标当中。其中正六边形网格的X坐标可以通过实际鼠标点击位置坐标除以正六边形地图块宽度获得。当Z为0时，Y与X互为镜像，则Y坐标的值与X坐标的值互为相反数。当X与Z坐标整体沿着Y产生偏移的时候，就需要将X与Z整体进行偏移。最后，将Z、Y、Z坐标进行四舍五入为整数，就可以得出最终的结果。代码如下：

```csharp
    public static HexCoordinates FromPosition(Vector3 position)
    {
        float x = position.x / (HexMetrics.innerRadius * 2f);
        float y = -x;

        float offset = position.z / (HexMetrics.outerRadius * 3f);
        x -= offset;
        y -= offset;

        int iX = Mathf.RoundToInt(x);
        int iY = Mathf.RoundToInt(y);
        int iZ = Mathf.RoundToInt(-x - y);

        return new HexCoordinates(iX, iZ);
    }
```

但是这种计算方式，最终在四舍五入的时候，可能会产生X、Y、Z之和部位0的情况，也就是在四舍五入时会产生误差。而且，鼠标点击位置距离一个正六边形地图块的重点越远，其四舍五入的误差越大，最终解决的方案是，舍弃具有最大舍入增量的坐标，并从其他两个坐标中重构它。代码如下：

```csharp
        if (iX + iY + iZ != 0)
        {
            float dX = Mathf.Abs(x - iX);
            float dY = Mathf.Abs(y - iY);
            float dZ = Mathf.Abs(-x - y - iZ);

            if (dX > dY && dX > dZ)
            {
                iX = -iY - iZ;
            }
            else if (dZ > dY)
            {
                iZ = -iX - iY;
            }
        }
```

#### 9. 点击改变颜色
现在，当鼠标点击的时候，就可以在Console面板中显示出当前点击的正六边形地图块的坐标了。但是这样并不直观，需要增加鼠标点击后，改变被点击的HexCell颜色的方法，在HexGrid.cs中添加两个变量，记录点击前和点击后颜色的值。代码如下：

```csharp
    public Color defaultColor = Color.white;
    public Color touchedColor = Color.magenta;
```

同时，需要在每个HexCell中记录自己的颜色值，HexCell也要同事添加一个记录颜色值的变量。代码如下：

```csharp
    public Color color;
```

在HexGrid.cs创建六边形的时候，同时要为每个六边形赋颜色值。在HexGrid.CreateCell方法中添加赋值颜色初始值语句。代码如下：

```csharp
        cell.color = defaultColor;
```

然后，在HexMesh创建六边形网格的时候，需要将每个HexCell的颜色值保存下来，并且在重新计算法线之前先赋值颜色值。HexMesh.cs代码修改如下：

```csharp
List<Color> colors;

void Awake()
{
    …
    colors = new List<Color>();
    …
}

public void Triangulate(HexCell[] cells)
{
    colors.Clear();
    …
    hexMesh.colors = colors.ToArray();
    …
}
```

在之前Triangulate方法中，依次取出正六边形两个顶点，加上中点组成一个三角形。每次取出的时候记录了顶点位置信息，这里还要增加记录顶点颜色信息的代码。修改代码如下：

```csharp
    void Triangulate(HexCell cell)
    {
        for (int i = 0; i < 6; i++)
        {
            …
            AddTriangleColor(cell.color);
        }
    }

    void AddTriangleColor(Color color)
    {
        colors.Add(color);
        colors.Add(color);
        colors.Add(color);
    }
```

现在返回HexGrid.TouchCell方法，当鼠标点击到正六边形上时候，通过已知的坐标换算为数组中的索引，这样就可以知道鼠标点击到哪个HexCell上了。最后再改变这个HexCell的颜色，得到鼠标点击后的响应效果。代码如下：

```csharp
    private void TouchCell(Vector3 position)
    {
        …
        int index = coordinates.X + coordinates.Z * width + coordinates.Z / 2;
        HexCell cell = cells[index];
        cell.color = touchedColor;
        hexMesh.Triangulate(cells);
        …
    }
```

最后，HexMesh所使用的默认Shader并不是使用顶点着色，这里需要创建一个自定义Shader，并修改其代码为顶点着色。这个Shader只需要两处修改。第一，将颜色数据添加到其输入结构体中。第二，将反照率乘以该颜色。这里只使用不透明材质，所以只需要关注RGB通道即可。代码与运行效果如下：

```csharp
Shader "Custom/VertexColors" {
	Properties{
		_Color("Color", Color) = (1,1,1,1)
		_MainTex("Albedo (RGB)", 2D) = "white" {}
		_Glossiness("Smoothness", Range(0,1)) = 0.5
		_Metallic("Metallic", Range(0,1)) = 0.0
	}
		SubShader{
			Tags { "RenderType" = "Opaque" }
			LOD 200

			CGPROGRAM
			#pragma surface surf Standard fullforwardshadows
			#pragma target 3.0

			sampler2D _MainTex;

			struct Input {
				float2 uv_MainTex;
				float4 color : COLOR;
			};

			half _Glossiness;
			half _Metallic;
			fixed4 _Color;

			void surf(Input IN, inout SurfaceOutputStandard o) {
				fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
				o.Albedo = c.rgb * IN.color;
				o.Metallic = _Metallic;
				o.Smoothness = _Glossiness;
				o.Alpha = c.a;
			}
			ENDCG
		}
			FallBack "Diffuse"
}
```

![被点击的HexCell改变颜色](https://catlikecoding.com/unity/tutorials/hex-map/part-1/interaction/colored-cells.png)

#### 10. 简单地图编辑器
目前，玩家已经可以通过点击鼠标来完成与地图系统的最基本的交互。接下来要完成基础的游戏内地图编辑器系统，所以要对目前的代码作出一些修改。在HexGrid.cs脚本内，删除touchedColor字段，同时修改TouchCell为带有Color参数的方法。代码如下：

```csharp
    public void ColorCell(Vector3 position, Color color)
    {
        position = transform.InverseTransformPoint(position);
        HexCoordinates coordinates = HexCoordinates.FromPosition(position);

        int index = coordinates.X + coordinates.Z * width + coordinates.Z / 2;
        HexCell cell = cells[index];
        cell.color = color;
        hexMesh.Triangulate(cells);
    }
```

新建脚本HexMapEditor.cs，这个脚本目前将负责存储多个颜色值，并将其赋值到不同的HexCell上。首先，要将HexGrid中的Update、HandleInput方法移动到HexMapEditor.cs中，接着创建一个引用HexGrid的公共变量。最后，创建一个颜色变量，来存储当前激活的颜色的值。代码如下：

```csharp
using UnityEngine;

public class HexMapEditor : MonoBehaviour
{
    public Color[] colors;

    public HexGrid hexGrid;

    private Color activeColor;

    void Awake()
    {
        SelectColor(0);
    }

    void Update()
    {
        if (Input.GetMouseButton(0))
        {
            HandleInput();
        }
    }

    void HandleInput()
    {
        Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        if (Physics.Raycast(inputRay, out hit))
        {
            hexGrid.ColorCell(hit.point, activeColor);
        }
    }

    public void SelectColor(int index)
    {
        activeColor = colors[index];
    }
}
```

HexMapEditor.cs脚本完成后，在场景中新建Canvas，保存吃其所有组件属性为默认，挂载HexMapEditor.cs.cs脚本，并在Inspector面板的colors数组进行初始化并赋值。结构如下图：

![新建Canvas](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/canvas.png)

接着，需要在新建Canvas下创建一组复选按钮组，用来选择鼠标点击后，正六边形所改变的颜色。通过GameObject / UI / Panel创建一个Panel作为单选按钮组的容器，将其调整至屏幕左上角，添加Toggle Group组件，Toggle Group组件可以让引用它的单选按钮自动成为一组。参数设置如下图：

![Panel参数设置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/panel-toggle-group.png)

在Panel下创建4个单选按钮，分别对应了HexMapEditor中的4个颜色。外观样式与文件结构如下图：

![单选按钮组外观样式](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/ui.png)
![单选按钮组层级结构](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/hierarchy.png)

四个单选按钮创建完成后，在其Toggle组件中，将Toggle Group的引用添加至Group变量中。四个单选按钮同时引用了Toggle Group组件，这样就实现了每次只有一种颜色被勾选的效果。
在单选按钮的Toggle组件中，每次组件值的改变，均会触发On Vaule Changed(Boolean)事件，这里事件回调需要执行HexMapEditor.SelectColor方法。点击On Vaule Changed(Boolean)面板右下角“+”，引用HexMapEditor.cs脚本，并找到SelectColor方法。其中传入参数依次从0到3。Toggle组件参数设置如下图：

![Toggle组件参数设置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/map-editor/toggle.png)

这样，就实现了，选择不同颜色，然后通过鼠标左键点击，让被点击的正六边形地图块显示不同的颜色的功能。不过，当鼠标点击任意一个正六边形地图块的时候，鼠标UI和正六边形地图块Mesh会同时做出响应，这样会造成逻辑和事件处理的混乱，所以，需要将这两个事件分别处理。这里使用Unity3D中EventSystems类监听鼠标是否悬停在UI上进行判断，HexMapEditor修改代码如下：

```csharp
using UnityEngine.EventSystems;

        …

    void Update()
    {
        if (Input.GetMouseButton(0) && !EventSystem.current.IsPointerOverGameObject())
        {
            HandleInput();
        }
    }
```

#### 11. 获取相邻的单元格
现在，正六边形地图已经可以响应鼠标的点击并按照UI中选中的颜色进行着色，而且可以获取到自身的坐标位置。但是当两个相邻的正六边形地图块颜色不同的时候，之间的过渡会显得格外生硬，所以需要将相邻的正六边形地图块两者的颜色，在接触的边界上进行混合。使两个相邻的正六边形地图块颜色过渡更加平滑。
进行颜色混合的第一部，是要获取每个正六边形地图块相邻的六个地图块。这里使用罗盘方向来识别它们。方向分别为东北、东、东南、西南、西、西北。示意如下图：

![相邻的六边形地图块](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/directions.png)

为了标记每个相邻的正六边形地图块的方位，最简便的方法就是使用枚举，创建HexDirection脚本，代码如下：

```csharp
public enum HexDirection
{
    NE,
    E,
    SE,
    SW,
    W,
    NW
}
```

接下来，需要在HexCell.cs脚本中添加一个数组，用来存储这个正六边形地图块周围六个相邻的地图块的实例。HexCell添加代码如下：

```csharp
    [SerializeField] private HexCell[] neighbors;
```

这样，选中HexCell Prefab后，在Inspector面板中，就可以看到neighbors数组了。这里需要将该数组的初始长度调整为6，用来存储相邻的正六边形地图块。如下图：

![neighbors初始长度为6](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/prefab.png)

数组长度设置完成后，需要在HexCell.cs脚本中继续添加为该数组中每个元素赋值(Set)和获取实例(Get)的方法。在赋值方法中，由于每个正六边形地图块相邻的只有六个地图块，不用关注索引越界的问题，所以不用验证。代码如下：

```csharp
    public HexCell GetNeighbor(HexDirection direction)
    {
        return neighbors[(int)direction];
    }

    public void SetNeighbor(HexDirection direction, HexCell cell)
    {
        neighbors[(int)direction] = cell;
    }
```

为了增加效率，减少遍历次数，在当前地图块添加其相邻地图块的时候，同时也将自身添加到相邻地图块的neighbors数组中，并同时计算其相对位置。如下图

![两个相邻正六边形地图块的相对位置](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/bidirectional.png)

在HexDirection.cs脚本中添加Opposite方法，在SetNeighbor方法执行时候进行调用。Opposite是用来计算当前地图块与其相邻地图块相对位置的方法。如果其相邻地图块枚举值小于3，则当前地图块枚举值要+3，反之，当前相邻地图块枚举值大于3，则当前地图块枚举值要-3。HexDirection.cs与HexCell.cs脚本如下：

```csharp
public static class HexDirectionExtensions
{
    public static HexDirection Opposite(this HexDirection direction)
    {

        if ((int)direction < 3)
        {
            return (direction + 3);
        }
        else
        {
            return (direction - 3);
        }
    }
}
```

```csharp
    public void SetNeighbor(HexDirection direction, HexCell cell)
    {
        neighbors[(int)direction] = cell;
        cell.neighbors[(int)direction.Opposite()] = this;
    }
```

#### 12. 链接相邻的单元格
添加相邻地图块的方法已经完成，接下来需要在地图块创建的时候为每个地图块中的数组赋值。各个地图块之间的链接关系，最简单的是W方位链接，但是这里需要注意一点，并非每个地图块都有完整的六个相邻的地图块。在边界处的地图块，与其相邻的地图块数量至少为2个，至多为5个。下图中使用数字来标记出了每个地图块有相邻地图块的数量：

![每个地图块相邻的地图块数量](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/neighbor-count.png)

通过观察上图可以发现，在最左侧的正六边形地图块，是没有W方位相邻地图块的。在HexGrid.CreateCell方法创建六边形地图快实例时，判断当前地图块是不是最左侧的一个，并建立W方位链接。示意图和代码修改如下：

![每个单元格W的链接关系](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/neighbors-e-w.png)

```csharp
    void CreateCell (int x, int z, int i)
    {
        …
        cell.color = defaultColor;

        if (x > 0)
        {
            cell.SetNeighbor(HexDirection.W, cells[i - 1]);
        }

        Text label = Instantiate<Text>(cellLabelPrefab);
        …
    }
```

接下来是创建SE链接，通过观察正六边形地图网格可以发现，地图网格中除了第一行的的偶数行，每一个地图块必有SE方位相位的地图块。首先判断地图块所在行是否为除第0行的偶数行，然后找到其上一行，并定位与之相邻的SE方位的地图块。示意图与代码如下：

![每个单元格SE的链接关系](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/neighbors-even-nw-se.png)

```csharp
        if (z > 0)
        {
            if ((z & 1) == 0)
            {
                cell.SetNeighbor(HexDirection.SE, cells[i - width]);
            }
        }
```

SW方位的连接关系与SE相类似，在除了第0行的偶数行中，每行第一个地图块是没有SW方位相邻的地图块。其他位置与SE方位链接类似，示意图与代码如下

![每个单元格SW的链接关系](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/neighbors-even-ne-sw.png)

```csharp
        if (z > 0)
        {
            if ((z & 1) == 0)
            {
                cell.SetNeighbor(HexDirection.SE, cells[i - width]);

                if (x > 0)
                {
                    cell.SetNeighbor(HexDirection.SW, cells[i - width - 1]);
                }
            }
        }
```

最后，其他未做判断的行中的地图块基本与之前的地图块逻辑相同，只不过其位置是镜像的，添加镜像的代码使其获得相邻地图块的链接。这样，所有的地图块与其相邻的地图块就建立了完整的方位链接，为下一步进行颜色混合做好了准备。修改代码与完成示意图如下：

```csharp
            else
            {
                cell.SetNeighbor(HexDirection.SW, cells[i - width]);
                if (x < width - 1)
                {
                    cell.SetNeighbor(HexDirection.SE, cells[i - width + 1]);
                }
            }
```

![所有相邻地图块都已链接](https://catlikecoding.com/unity/tutorials/hex-map/part-2/cell-neighbors/all-connected.png)

#### 13. 拆分正六边形地图块
混合色彩的下一步，要将每个正六边形地图块进行拆分。因为现在每个正六边形地图块只能进行单一颜色的着色，也就是所有顶点的颜色都相同。而颜色混合是要将每个正六边形地图块不同的顶点赋值不同的颜色。现在使用HexDirection中的方位来标识每一个正六边形地图块中的各个顶点。这一步在HexMesh.cs的Triangulate方法创建正六边形地图块时执行，修改代码如下：

```csharp
    void Triangulate(HexCell cell)
    {
        for (HexDirection d = HexDirection.NE; d <= HexDirection.NW; d++)
        {
            Triangulate(d, cell);
        }
    }

    private void Triangulate(HexDirection direction, HexCell cell)
    {
        Vector3 center = cell.transform.localPosition;

        for (int i = 0; i < 6; i++)
        {
            AddTriangle(
                center,
                center + HexMetrics.corners[(int)direction],
                center + HexMetrics.corners[(int)direction + 1]
            );

            AddTriangleColor(cell.color);
        }
    }
```
这样就酱每个顶点赋值了方位属性，但是这里在添加顶点时，还是用到了数字索引，并没有完全实现使用方位进行赋值，所以，要修改HexMetrics.cs，在其中加入获取第一个顶点方位和下一个顶点方位的静态方法。HexMetrics.cs与HexMesh.cs修改如下

```csharp
    public static Vector3 GetFirstCorner(HexDirection direction)
    {
        return corners[(int)direction];
    }

    public static Vector3 GetSecondCorner(HexDirection direction)
    {
        return corners[(int)direction + 1];
    }
```

```csharp
            AddTriangle(
                center,
                center + HexMetrics.GetFirstCorner(direction),
                center + HexMetrics.GetSecondCorner(direction)
            );
```

#### 14. 三角形面片多色着色
将正六边形地图块中每个顶点拆分完成后，就可以为每个顶点单独着色。在HexMesh.AddTriangleColor方法中，传入的参数只有一个颜色值，三角形的三个顶点都使用了这个颜色。现在修改这个方法的参数，使其传入三个颜色值，为每个顶点赋值不同的颜色。修改代码如下：

```csharp
    private void AddTriangleColor(Color c1, Color c2, Color c3)
    {
        colors.Add(c1);
        colors.Add(c2);
        colors.Add(c3);
    }
```

这样就可以进行颜色的混合了，在创建三角形面片的时候，Triangulate方法调用了AddTriangleColor进行颜色赋值，这里要修改Triangulate赋值颜色的部分，先获取其相邻正六边形地图块中顶点的颜色值，然后将颜色值分别赋值给三个顶点，Unity3D将自动混合这些颜色。代码如下

```csharp
    private void Triangulate(HexDirection direction, HexCell cell)
    {
            …

            HexCell neighbor = cell.GetNeighbor(direction);
            AddTriangleColor(cell.color, neighbor.color, neighbor.color);
        }
    }
```

这样赋值会产生一个问题，之前在链接每个地图块相邻的地图块时，并非每个地图块都有六个相邻的地图块。所以在顶点赋值颜色的时候会有NullReferenceException错误。这里通过判断是否有相邻的地图块，如果没有，就使用自身的颜色进行赋值，修改代码如下：

```csharp
    private void Triangulate(HexDirection direction, HexCell cell)
    {
            …

            HexCell neighbor = cell.GetNeighbor(direction) ?? cell;
            AddTriangleColor(cell.color, neighbor.color, neighbor.color);
        }
    }
```

最后，每个顶点都正确获取了颜色值，在创建三角面片的时候进行了颜色的混合，但是视距效果并不理想，如下图：

![错误的颜色混合](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blending-colors/direct-neighbor-colors.png)

#### 15. 重新平均计算颜色
获取相邻顶点颜色进行混合并着色后，产生了不一样的结果，颜色混合最终期望的结果是：正六边形地图块中心点的颜色为自身的颜色，边缘的颜色是两个相邻正六边形地图块颜色的平均值。代码修改与云翔效果如下：

```csharp
    private void Triangulate(HexDirection direction, HexCell cell)
    {
            …

            HexCell neighbor = cell.GetNeighbor(direction) ?? cell;
            Color edgeColor = (cell.color + neighbor.color) * 0.5f;
            AddTriangleColor(cell.color, edgeColor, edgeColor);
        }
    }
```

![重新进行边缘颜色融合](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blending-colors/edge-average-colors.png)


经过重新计算颜色平均值后，颜色混合的视觉效果相对正确了。但是在两个颜色相交的边缘处，仍然可以看到明显的交界。发生这种现象的原因是，每个顶点会被三个正六边形所公用，如下图所示：

![三者相邻，四种颜色](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blending-colors/three-neighbors.png)

这种情况意味着，在与N进行颜色混合的时候，还需要考虑到N-1与N+1的颜色。因此，最终得到了四种颜色，分为两组，每组三个。在HexDirectionExtensions静态类中添加Previous和Next，同股哟这两个方法，可以找打N-1与N+1的实例。代码如下：


```csharp
public static class HexDirectionExtensions
{
    …

    public static HexDirection Previous(this HexDirection direction)
    {
        return direction == HexDirection.NE ? HexDirection.NW : (direction - 1);
    }

    public static HexDirection Next(this HexDirection direction)
    {
        return direction == HexDirection.NW ? HexDirection.NE : (direction + 1);
    }
}
```

通过这两个方法，在创建每个三角面片的时候，可以找到N-1与N+1的颜色，进行混合后赋值。修改代码如下

```csharp
            …

            HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell;
            HexCell neighbor = cell.GetNeighbor(direction) ?? cell;
            HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell;

            AddTriangleColor(
                cell.color,
                (cell.color + prevNeighbor.color + neighbor.color) / 3f,
                (cell.color + neighbor.color + nextNeighbor.color) / 3f
            );
```

经过这种方式的颜色混合，在视觉效果上相对平滑。但是对于六边形地图边界的地图块，颜色会有混合问题。并且边界上两个正六边形地图块之间的颜色混合依然会有很明显的边界过渡。所以，如果仅仅是使用单一的三角面片区域进行颜色混合，达不到最终的视觉效果要求，如下图所示：

![边界处有明显的过渡效果](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blending-colors/corner-average-colors.png)

#### 16. 创建颜色混合区域
经过之前章节的试验，得出的结论是：在正六边形地图块的三角面片中直接进行颜色混合，会导致混合后的颜色混乱，每个正六边形地图块之间的边界变得模糊，而且在地图边缘的正六边形地图块之间的过渡非常不自然。所以，另一种方案是：六边形地图块自身颜色保持不变，而在正六边形地图块边缘创建一个颜色融合区域。这样既保证视觉效果上可以很清晰的分辨出每个正六边形地图块，又保证了在每个正六边形地图块之间有很自然的过渡。如下图所示

![颜色混合区域](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blend-regions/blend-regions.png)

颜色混合区域为正六边形地图块的一部分，所以将正六边形地图块分割为两部分，其中正六边形地图块占外接圆半径的75%，混合区域占外接圆半径的25%，两者之和为外接圆半径的100%。同时在HexMetrics.cs中创建新的方法，用来检索新的正六边形地图块的顶点位置信息。代码如下：

```csharp
    public const float solidFactor = 0.75f;
    public const float blendFactor = 1f - solidFactor;

    public static Vector3 GetFirstSolidCorner(HexDirection direction)
    {
        return corners[(int)direction] * solidFactor;
    }

    public static Vector3 GetSecondSolidCorner(HexDirection direction)
    {
        return corners[(int)direction + 1] * solidFactor;
    }
```

接下来，对HexMesh.Triangulate方法进行修改，在创建正六边形地图块的时候，使其使用新的顶点位置信息，而不是原始的顶点位置信息。代码与运行效果如下：

```csharp
    private void Triangulate(HexDirection direction, HexCell cell)
    {
            …

            AddTriangle(
                center,
                center + HexMetrics.GetFirstSolidCorner(direction),
                center + HexMetrics.GetSecondSolidCorner(direction)
            );
    }
```

![添加了混合区域的地图](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blend-regions/solid-hexagons.png)

#### 17. 三角化颜色混合区域
经过之前的代码，这里将一个三角面片分为了两部分，如下图所示。完整的三角面片为center-v3-v4，经过拆分后，center-v1-v2为实际正六边形地图块的区域，显示自身的颜色。v1-v2-v4-v3为颜色混合区域，讲相邻地图块颜色混合后在这个区域显示。

![三角面片的两部分](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blend-regions/trapezoid.png)

要进行颜色混合，首先要将该梯形区域转化为三角面片所组成的区域，并且记录该区域内每个顶点的颜色信息。在HexMesh.cs中添加创建颜色混合梯形区域顶点的方法和记录颜色值的方法。并且在创建正六边形地图块的时候，同时创建颜色混合区域并进行颜色混合。代码如下：

```csharp
   private void Triangulate(HexDirection direction, HexCell cell)
    {
        Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction);
        Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction);

        Vector3 v3 = center + HexMetrics.GetFirstCorner(direction);
        Vector3 v4 = center + HexMetrics.GetSecondCorner(direction);


        for (int i = 0; i < 6; i++)
        {
            AddQuad(v1, v2, v3, v4);

            HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell;
            HexCell neighbor = cell.GetNeighbor(direction) ?? cell;
            HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell;



            AddTriangleColor(cell.color);

            AddQuadColor(
                cell.color,
                cell.color,
                (cell.color + prevNeighbor.color + neighbor.color) / 3f,
                (cell.color + neighbor.color + nextNeighbor.color) / 3f
             );
        }
    }

    void AddQuad(Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4)
    {
        int vertexIndex = vertices.Count;
        vertices.Add(v1);
        vertices.Add(v2);
        vertices.Add(v3);
        vertices.Add(v4);
        triangles.Add(vertexIndex);
        triangles.Add(vertexIndex + 2);
        triangles.Add(vertexIndex + 1);
        triangles.Add(vertexIndex + 1);
        triangles.Add(vertexIndex + 2);
        triangles.Add(vertexIndex + 3);
    }

    void AddQuadColor(Color c1, Color c2, Color c3, Color c4)
    {
        colors.Add(c1);
        colors.Add(c2);
        colors.Add(c3);
        colors.Add(c4);
    }
```

这样，每个正六边形地图块只显示自身的颜色，而混合区域则会进行颜色计算和混合。但是在混合区域内，相邻的混合区域间产生了颜色污染，同时，边缘处的地图块颜色显示也不正常，如下图：

![在颜色混合区域内进行颜色混合](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blend-regions/blend-trapezoids.png)

#### 18. 拆分颜色混合区域
相比于在正六边形地图块上直接进行颜色混合，创建一个单独的颜色混合区域，视觉效果更好，更便于控制各种颜色在混合区域内的值。但是在相邻的颜色混合区域内，还是存在颜色污染的问题，这个问题的主要原因依然是一个顶点被多个正六边形共享了。这里将颜色混合区域和多个正六边形地图块颜色共享区域分开，如下图：

![拆分后的颜色混合区域](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blend-regions/edge-bridge.png)

图中黄色矩形部分为连接两个正六边形地图块之间的桥梁，黄色矩形部分只进行两个相邻正六边形地图块颜色的混合。而黄色矩形两侧的三角形部分，存在三个正六边形地图块共用顶点的情况，所以要进行拆分后分别计算。在这里，可以通过上图的V1、V2来找到V3、V4的位置。在HexMetrics.cs中田间静态方法，代码如下：

```csharp
    public static Vector3 GetBridge(HexDirection direction)
    {
        return (corners[(int)direction] + corners[(int)direction + 1]) *
            0.5f * blendFactor;
    }
```

在拆分了混合区域之后，同样要对创建三角面片时赋值颜色的方法进行修改，在HexMesh.AddQuadColor方法中，现在只需要混合两个相邻正六边形地图块的颜色，所以参数只需要两个颜色值即可，代码如下：

```csharp
    private void AddQuadColor(Color c1, Color c2)
    {
        colors.Add(c1);
        colors.Add(c1);
        colors.Add(c2);
        colors.Add(c2);
    }
```

最后，修改HexMesh.Triangulate方法，只创建V1-V2-V4-V3作为颜色混合区域，修改代码如下：

```csharp
        Vector3 bridge = HexMetrics.GetBridge(direction);
        Vector3 v3 = v1 + bridge;
        Vector3 v4 = v2 + bridge;

        AddQuadColor(cell.color, (cell.color + neighbor.color) * 0.5f);
```

这样，在进行颜色混合时，该矩形区域只负责混合两个相邻的正六边形地图块之间的颜色，位于地图中间和地图边缘的正六边形地图块，颜色混合的视觉效果完全正确。如下图：

![新的颜色混合区域](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blend-regions/bridges-only.png)


#### 19. 填补多色混合区域
现在，相邻整六边形地图块之间的颜色混合已经在视觉效果上完全正常了，接下来需要填补多色混合区域。多色混合区域位于矩形颜色混合区域的两侧，都是一个三角面片所组成的区域。第一个顶点的颜色为六边形地图快自身的颜色，第二个顶点的颜色为三个六边形地图块颜色的混合，第三个顶点的颜色为矩形颜色混合区域的颜色。HexMesh.Triangulate方法修改与效果如下：

```csharp
            Color bridgeColor = (cell.color + neighbor.color) * 0.5f;
            AddQuadColor(cell.color, bridgeColor);

            AddTriangle(v1, center + HexMetrics.GetFirstCorner(direction), v3);
            AddTriangleColor(
                cell.color,
                (cell.color + prevNeighbor.color + neighbor.color) / 3f,
                bridgeColor
            );
```

![一侧的多色混合区域](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blend-regions/one-corner.png)

另一侧的多色混合区域与之前的创建方法相类似，只是将边缘处两个顶点的颜色值互换，代码如下：

```csharp
            AddTriangle(v2, v4, center + HexMetrics.GetSecondCorner(direction));
            AddTriangleColor(
                cell.color,
                bridgeColor,
                (cell.color + neighbor.color + nextNeighbor.color) / 3f
            );
```

最后，如下图中所示，产生了正确的颜色混合效果，颜色混合的区域的大小还可以通过系数进行调整。

![正确的颜色混合](https://catlikecoding.com/unity/tutorials/hex-map/part-2/blend-regions/full-blending.png)

#### 19. 优化矩形颜色混合区域

颜色混合区域在视距效果上完全正常，但是还存在可以进一步优化的空间。在Unity3D中选中六边形地图时，Scene窗中的内容如下图所示。

![正六边形地图的三角面](https://catlikecoding.com/unity/tutorials/hex-map/part-2/fusing-edges/many-triangles.png)

相邻正六边形颜色混合区域是由4个三角面片组成的，三种颜色的混合区域中三角面片还会更多，三角面片的数量会在很大程度上影响程序的运行效率，当地图由几万甚至几十万个正六边形地图块组成时，这些颜色混合区域很可能造成游戏运行的卡顿、掉帧等情况。

为了更加直观的观察这些正六边形之间的关系，这里将相邻的3个正六边形地图块抽象出来。如下图：

![三个相邻的六边形地图块](https://catlikecoding.com/unity/tutorials/hex-map/part-2/fusing-edges/three-different-shapes.png)

在图中，绿色部分是由4个三角面片组成，紫色部分由6个三角面片组成。这里可以将绿色区域优化为两个三角面片，紫色区域优化为一个三角面片。这里，修改HexMetrics.GetBridge方法，将矩形颜色混合区域的两个外侧顶点位置设置到相邻正六边形的顶点位置。修改代码与效果如下：

```csharp
    public static Vector3 GetBridge(HexDirection direction)
    {
        return (corners[(int)direction] + corners[(int)direction + 1]) * blendFactor;
    }
```

![拉伸后的颜色混合区域](https://catlikecoding.com/unity/tutorials/hex-map/part-2/fusing-edges/single-bridges.png)

虽然市局效果上连接两个正六边形的矩形颜色混合区域由两个三角面片构成，但其实另一矩形颜色混合区域是重叠在另一个的下方。所以必须删除一个矩形颜色混合区域。修改HexMesh.Triangulate方法，在构建矩形颜色混合区域时，重新计算顶点的位置和颜色。修改代码如下：

```csharp
    private void Triangulate(HexDirection direction, HexCell cell)
    {
        Vector3 center = cell.transform.localPosition;
        Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction);
        Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction);

        AddTriangle(center, v1, v2);
        AddTriangleColor(cell.color);
    }

    private void TriangulateConnection(HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2)
    {
        HexCell neighbor = cell.GetNeighbor(direction) ?? cell;

        Vector3 bridge = HexMetrics.GetBridge(direction);
        Vector3 v3 = v1 + bridge;
        Vector3 v4 = v2 + bridge;

        AddQuad(v1, v2, v3, v4);
        AddQuadColor(cell.color, neighbor.color);
    }
```
计算出矩形颜色混合区域后，与之间的创建过程类似，这里首先创建NE方位的矩形颜色混合区域，代码与修改效果如下：

```csharp
        if (direction == HexDirection.NE)
        {
            TriangulateConnection(direction, cell, v1, v2);
        }
```

![NE方位的颜色混合区域](https://catlikecoding.com/unity/tutorials/hex-map/part-2/fusing-edges/ne-bridges.png)

现在，每个正六边形地图块在NE方位的颜色混合区域，视距效果完全正确了，根据这个结果，每个正六边形地图块只需要创建NE、E、SE方向的颜色混合区域即可，代码修改与效果如下：

```csharp
        if (direction <= HexDirection.SE)
        {
            TriangulateConnection(direction, cell, v1, v2);
        }
```

![NE E SE方位的颜色混合区域](https://catlikecoding.com/unity/tutorials/hex-map/part-2/fusing-edges/all-bridges.png)

根据上图的运行结果分析，现在所有的颜色混合区域都已经正确的生成了，但是在地图边界的正六边形地图块生成了多余的颜色混合区域，修改TriangulateConnection方法，在检测到没有相邻的正六边形地图块时，将不再生成颜色混合区域，代码修改与运行效果如下：

```csharp
        HexCell neighbor = cell.GetNeighbor(direction);
        if (neighbor == null)
        {
            return;
        }
```

![优化后的矩形颜色混合区域](https://catlikecoding.com/unity/tutorials/hex-map/part-2/fusing-edges/only-internal-bridges.png)

#### 20. 优化三角形颜色混合区域
接下来，需要优化地图中孔雀的三角形颜色混合区域。首先，在生成颜色混合区域的时候，需要确定在该方位是否有正六边形地图块与之相邻，否则会产生报错。TriangulateConnection方法代码修改如下：

```csharp
        HexCell nextNeighbor = cell.GetNeighbor(direction.Next());
        if (nextNeighbor != null)
        {
            AddTriangle(v2, v4, v2);
            AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color);
        }
```

这里创建三角形时，AddTriangle的第三个参数v2显然是不对的，这里只是为了避免报错而临时使用了一个变量。通过观察运行效果，三角形面片的每一个边都与一个矩形颜色混合区域的边位置相同，所以可以根据矩形颜色混合区域的顶点位置来确定三角形颜色混合区域的顶点位置。代码修改如下：

```csharp
            AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next()));
```

方法修改之后，虽然三角形可以正确生成了，但是仔细分析该方法可以发现，在生成三角形颜色混合区域的时候，是会在一个位置生成多个。由于一个三角形颜色混合区域是被多个正六边形地图块所共享的，所以只要构建NE、E方位的三角形颜色混合区域即可。代码修改与运行效果如下：

```csharp
        if (direction <= HexDirection.E && nextNeighbor != null)
        {
            AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next()));

            AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color);
        }
```

![三角形颜色混合区域](https://catlikecoding.com/unity/tutorials/hex-map/part-2/fusing-edges/all-connections.png)


#### 21. 创建可编辑的正六边形地图块高度UI---
在地形系统中，除了通过颜色表示地形的种类，还需要有高度来模拟高地、悬崖和盆地等地貌。HexMap模拟地��的高度思路，是单独为每一个正六边形地图块赋予单独的海拔高度，在HexCell.cs中添加如下代码：

```csharp
    public int elevation;
```

接下来，需要定义两个海拔高度之间的跨度。需要定义HexMetrics常量，这个常量表示了两个连续海拔高度之间的跨度值，设定该值为5，为了更明显的观察两个不同海拔高度的正六边形地图块之间的过渡，便于发现BUG和修改。在实际游戏中，跨度值则会比较小，使地形高度变化看起来更平滑。HexCell.cs添加代码如下：

```csharp
    public const float elevationStep = 5f;
```

接下来，需要修改HexGrid.ColorCell方法，这个方法只能编辑每个正六边形地图块的颜色，无法满足现在更改单个正六边形地图块海拔高度的需求。创建一个新的GetCell方法，该方法通过鼠标点击位置，获取到当前鼠标点击的正六边形地图块，转换坐标后返回该正六边形地图块在地图数组中的索引。修改代码如下：

```csharp
    public HexCell GetCell(Vector3 position)
    {
        position = transform.InverseTransformPoint(position);
        HexCoordinates coordinates = HexCoordinates.FromPosition(position);
        int index = coordinates.X + coordinates.Z * width + coordinates.Z / 2;
        return cells[index];
    }
```

由于不再使用HexGrid.ColorCell方法进行每个正六边形地图块的编辑操作，所以在其他外部方法更改高度之后，要重新进行正六边形地图块的三角剖分计算，在计算完成后，刷新整个地图，将计算后的数据显示在地图上。HexGrid.cs中添加Refresh方法，代码如下：

```csharp
    public void Refresh()
    {
        hexMesh.Triangulate(cells);
    }
```

接下来，在HexMapEditor.cs中，添加一个新的EditCell方法，该方法负责处理编辑正六边形地图块的所有操作，当操作完成之后，调用由于不再使用HexGrid.Refresh方法，刷新地图。代码如下：

```csharp
    void HandleInput()
    {
        …

        if (Physics.Raycast(inputRay, out hit))
        {

            EditCell(hexGrid.GetCell(hit.point));
        }
    }

    private void EditCell(HexCell cell)
    {
        cell.color = activeColor;
        hexGrid.Refresh();
    }
```

EditCell方法创建完成后，在方法内就可以将需要的海拔高度赋值给当前所选中的正六边形地图块了。修改代码如下：

```csharp
    private int activeElevation;

    void EditCell(HexCell cell)
    {
        cell.color = activeColor;
        cell.elevation = activeElevation;
        hexGrid.Refresh();
    }
```

与为每个正六边形地图块赋值颜色类似，也需要一个方法为每个正六边形地图块赋值海拔高度，并将其在UI上表现出来。创建SetElevation方法，代码如下：

```csharp
    public void SetElevation(float elevation)
    {
        activeElevation = (int)elevation;
    }
```

这里之所以要将输入的float类型数据转换为int类型数据，是因为Unity UGUI Slider组件中，输入值只能为float类型。接下来通过GameObject / Create / Slider将滑块添加到HexMapEditor中，其设置为从下到上的垂直滑块，以便在视觉上与高程级别匹配。将其限制为整数，并给它一个合理的范围，例如0到6。然后将其On Value Changed事件挂接到HexMapEditor.SetElevation方法。这样，当拖动滑块时，就可以改变当前选中的正六边形地图块的海拔高度了。如下图：

(图 21.jpg)

#### 22. 显示正六边形地图块的海拔高度
接下来需要完善改变正六边形地图块海拔高度的方法，使其可以在三角剖分之前读取到UI的海拔高度信息，选中一个正六边形地图块时，就可以同时更改其颜色和海拔高度了。代码与运行效果如下：

```csharp
    private int elevation;

    public int Elevation
    {
        get
        {
            return elevation;
        }
        set
        {
            elevation = value;
            Vector3 position = transform.localPosition;
            position.y = value * HexMetrics.elevationStep;
            transform.localPosition = position;
        }
    }
```

![不同高度低正六边形地图块](https://catlikecoding.com/unity/tutorials/hex-map/part-3/cell-elevation/visualization.png)

从运行效果图中可以发现两个问题，第一，当一个正六边形地图块高于原始高度时，其显示坐标的数字并没有和它保持相同的高度。第二，升高的正六边形地图块与其周边的地图块连接会断开，这样在逻辑和视觉效果中是错误的。

#### 23. 重新定位坐标显示UI
首先修复坐标的数字并没有和正六边形地图块保持相同的高度的问题。这个问题发生的原因是，在生成UI时，使用了默认的高度位置，当正六边形地图块高度发生改变的时候，坐标显示UI并没有更新到新的高度位置。修改代码如下：

```csharp
    public int Elevation
    {
        …

        set
        {
            elevation = value;
            Vector3 position = transform.localPosition;
            position.y = value * HexMetrics.elevationStep;
            transform.localPosition = position;

            Vector3 uiPosition = uiRect.localPosition;
            uiPosition.z = elevation * -HexMetrics.elevationStep;
            uiRect.localPosition = uiPosition;
        }
    }
```

![UI在正确的高度显示](https://catlikecoding.com/unity/tutorials/hex-map/part-3/cell-elevation/elevated-labels.png)

#### 24. 创建正六边形地图块的高差连接
接下来，需要解决两个高度不同的正六边形地图块之间的连接问题。这里需要修改HexMesh.TriangulateConnection方法，在进行相邻端点连接的时候，要加入高度值，修改代码与运行效果如下：

```csharp
    private void TriangulateConnection(HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2)
    {
        …

        Vector3 bridge = HexMetrics.GetBridge(direction);
        Vector3 v3 = v1 + bridge;
        Vector3 v4 = v2 + bridge;

        …

        if (direction <= HexDirection.E && nextNeighbor != null)
        {
            Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next());
            v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep;
            AddTriangle(v2, v4, v5);

            AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color);
        }
    }
```

![正六边形地图块之间连接正确](https://catlikecoding.com/unity/tutorials/hex-map/part-3/cell-elevation/elevated-connections.png)

但是，这里连接虽然正确显示，但是如果两个相邻的正六边形地图块高差很大，其相邻的连接部分会显得很突兀。类似《无尽传奇》游戏中的类似地图系统，处理这种平滑连接的方法，一般是将这个平面进行三角剖分，以阶梯状的形式重新创建三角面片，这样会使地图看来细节更加丰富，也更具有立体感。

(此处需要无尽传奇的游戏截图)

#### 25. 创建梯度连接
为了增加地图的细节和立体感，在两个高度不同的正六边形地图块之间，以数个“过渡台阶”的形式连接来解决这个问题。例如，在两个相邻且相差1个单位高度的正六边形地图块之间，插入两个“过渡台阶”，如下图所示：

![高度不同相邻地图块之间的连接方式](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-edge-connections/terraces.png)

按照此思路，首先要设置一个常量，用来规定两个相邻且相差差1个高度单位的正六边形地图块之间，需要多少个“过渡台阶”。接着要计算出每个“过渡台阶”在水平和垂直方向上的宽度和高度，分别占用宽度和高度的百分比，这个百分比是用来计算“过渡台阶”中，每个三角面片顶点的具体位置，还可以通过这个百分比计算出每个顶点的颜色值，为整个连接部分进行着色。HexMetrics.cs代码修改如下：

```csharp
    public const int terracesPerSlope = 2;

    public const int terraceSteps = terracesPerSlope * 2 + 1;

    public const float horizontalTerraceStepSize = 1f / terraceSteps;

    public const float verticalTerraceStepSize = 1f / (terracesPerSlope + 1);

    public static Vector3 TerraceLerp(Vector3 a, Vector3 b, int step)
    {
        float h = step * HexMetrics.horizontalTerraceStepSize;
        a.x += (b.x - a.x) * h;
        a.z += (b.z - a.z) * h;
        float v = ((step + 1) / 2) * HexMetrics.verticalTerraceStepSize;
        a.y += (b.y - a.y) * v;
        return a;
    }

    public static Color TerraceLerp(Color a, Color b, int step)
    {
        float h = step * HexMetrics.horizontalTerraceStepSize;
        return Color.Lerp(a, b, h);
    }
```

#### 26. 连接区域的三角剖分
完成了计算“过渡台阶”的基础方法，接下来要通过三角剖分来创建两个相邻正六边形地图块的连接区域。首先需要修改HexMesh.TriangulateConnection方法，在之前的方法中，只是获取了相邻正六边形地图块各自的2个顶点位置信息，创建了简单的连接区域。这里需要通过HexMetrics.TerraceLerp方法，计算每一个“过渡台阶”的高度与宽度，这里先生成过渡台阶的第一部分，代码与运行效果图如下：

```csharp
    private void TriangulateConnection(HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2)
    {
        HexCell neighbor = cell.GetNeighbor(direction);
        if (neighbor == null)
        {
            return;
        }

        Vector3 bridge = HexMetrics.GetBridge(direction);
        Vector3 v3 = v1 + bridge;
        Vector3 v4 = v2 + bridge;

        v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep;

        TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor);

        HexCell nextNeighbor = cell.GetNeighbor(direction.Next());
        if (direction <= HexDirection.E && nextNeighbor != null)
        {
            Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next());
            v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep;
            AddTriangle(v2, v4, v5);

            AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color);
        }
    }

    private void TriangulateEdgeTerraces(
        Vector3 beginLeft, Vector3 beginRight, HexCell beginCell,
        Vector3 endLeft, Vector3 endRight, HexCell endCell)
    {
        Vector3 v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, 1);
        Vector3 v4 = HexMetrics.TerraceLerp(beginRight, endRight, 1);
        Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, 1);

        AddQuad(beginLeft, beginRight, v3, v4);
        AddQuadColor(beginCell.color, c2);
    }
```

![生成的第一段台阶](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-edge-connections/first-step.png)

接下来，这里直接跳转至最后一个步骤，将已经创建好的“过渡台阶”直接与正六边形地图块相连，修改代码与运行效果图如下：

```csharp
    private void TriangulateEdgeTerraces(
        Vector3 beginLeft, Vector3 beginRight, HexCell beginCell,
        Vector3 endLeft, Vector3 endRight, HexCell endCell)
    {
        Vector3 v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, 1);
        Vector3 v4 = HexMetrics.TerraceLerp(beginRight, endRight, 1);
        Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, 1);

        AddQuad(beginLeft, beginRight, v3, v4);
        AddQuadColor(beginCell.color, c2);

        AddQuad(v3, v4, endLeft, endRight);
        AddQuadColor(c2, endCell.color);
    }
```

![剩余的连接部分](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-edge-connections/last-step.png)

最后，可以通过一个循环，读取台阶段数的常量，生成剩余的“过渡台阶”，修改代码与运行效果图如下：

```csharp
        for (int i = 2; i < HexMetrics.terraceSteps; i++)
        {
            Vector3 v1 = v3;
            Vector3 v2 = v4;
            Color c1 = c2;
            v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, i);
            v4 = HexMetrics.TerraceLerp(beginRight, endRight, i);
            c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i);
            AddQuad(v1, v2, v3, v4);
            AddQuadColor(c1, c2);
        }
```

![正确生成的过渡台阶](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-edge-connections/all-terraces.png)

至此，所有相邻有高差的正六边形地图块，由原来的矩形连接方式，变成了有“过渡台阶”的连接方式，但是，通过运行后的视觉效果来看，存在以下两个问题：
问题1：矩形连接区域变为台阶类型后，其两侧的三角形连接区域并没有随之改变，这样会在台阶两侧露出缝隙。
问题2：两个相邻的正六边形地图块高差如果大于1个单位高度，“过渡台阶”的跨度就会显得非常大，视觉效果并不美观。
综合以上两个问题，首先要修复三角形连接区域的三角剖分问题，使其能完全贴合“过渡台阶”的边缘，其次是要对不同高差相邻请款的区分处理。

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-edge-connections/always-terraces.png)

#### 27. 定义不同的连接类型
现在两个相邻的正六边形地图块之间已经生成了“过渡台阶”，但是仔细观察可以发现，即使高差相同的两个正六边形地图块之间的连接区域，也会生成“过渡台阶”，虽然在视觉效果上与之前没没有差别，但是产生了很多三角面，对硬件性能是一种浪费。其次，在相邻且高差大于1个单位的正六边形地图块之间，生成的“过渡台阶”视觉效果并不美观，这种情况下应该保持原有的平面类型，而不是台阶类型。所以，此处声明一个枚举，用来定义不同的地形，代码如下：

```csharp
public enum HexEdgeType
{
    Flat,
    Slope,
    Cliff
}
```
接下来，需要在生成之前进行计算，两个相邻的正六边形地图块连接部分属于哪种类型。HexMetrics.cs代码修改如下：

```csharp
    public static HexEdgeType GetEdgeType(int elevation1, int elevation2)
    {
        if (elevation1 == elevation2)
        {
            return HexEdgeType.Flat;
        }
        int delta = elevation2 - elevation1;
        if (delta == 1 || delta == -1)
        {
            return HexEdgeType.Slope;
        }
        return HexEdgeType.Cliff;
    }
```

最后，还需要在HexCell.cs中添加一个获取当前正六边形地图块指定方向位置的连接区域类型的方法，代码如下：

```csharp
    public HexEdgeType GetEdgeType(HexDirection direction)
    {
        return HexMetrics.GetEdgeType(
            elevation, neighbors[(int)direction].elevation
        );
    }
```

#### 28. 修正连接区域
将连接区域的类型设置完成后，就可以返回HexMesh.cs中，修改三角剖分的代码，通过判断不同类型的连接区域，就可以对该连接区域进行不同的三角剖分，代码与运行效果图如下：

```csharp
    private void TriangulateConnection(HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2)
    {
        …

        if (cell.GetEdgeType(direction) == HexEdgeType.Slope)
        {
            TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor);
        }
        else
        {
            AddQuad(v1, v2, v3, v4);
            AddQuadColor(cell.color, neighbor.color);
        }

        …
    }
```

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/connection-types/slope-terraces.png)

#### 29. 三角形连接区域高度排序
三角形连接区域相比矩形连接区域更加复杂，因为它涉及到了三个正六边形地图块。三角形连接区域的每个顶点都连接到一个正六边形地图块的顶点上，这些正六边形地图块可能是Flat、Slope、Cliff中的任意一种。首先需要为三角形连接区域所相邻的三个正六边形地图块进行排序，以便知道哪个正六边形地图块在三个之中的相对高度最低。这里规定先从正下方的正六边形地图块开始，接着是左上方，然后是右上方，如下图所示：

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-corner-connections/triangle.png)

规定了判断顺序之后，接下来的三角剖分处理方式与矩形连接区域比较相似，在HexMesh.cs中添加新的方法，代码如下：

```csharp
    private void TriangulateCorner(
        Vector3 bottom, HexCell bottomCell,
        Vector3 left, HexCell leftCell,
        Vector3 right, HexCell rightCell
    )
    {
        AddTriangle(bottom, left, right);
        AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color);
    }
```

接下来，在创建三角形连接区域的时候，通过规定好的顺序，在HexMesh.TriangulateConnection中判断哪个正六边形地图块是相对高度最低的那一个。代码如下：

```csharp
    private void TriangulateConnection(HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2)
    {
        …

        if (direction <= HexDirection.E && nextNeighbor != null)
        {
            Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next());
            v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep;
            AddTriangle(v2, v4, v5);

            if (cell.Elevation <= neighbor.Elevation)
            {
                if (cell.Elevation <= nextNeighbor.Elevation)
                {
                    TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor);
                }
                else
                {
                    TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor);
                }
            }
            else if (neighbor.Elevation <= nextNeighbor.Elevation)
            {
                TriangulateCorner(v4, neighbor, v5, nextNeighbor, v2, cell);
            }
            else
            {
                TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor);
            }

            AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color);
        }
    }
```

#### 30. 相邻斜坡边缘的三角剖分
对三角形连接区域周边的正六边形地图块按照从低到高排序后，就可以进行三角连接区域的三角剖分了。为了方便判断两个正六边形地图块的相对高度，这里在HexCell中添加GetEdgeType方法，代码如下：

```csharp
    public HexEdgeType GetEdgeType(HexCell otherCell)
    {
        return HexMetrics.GetEdgeType(
            elevation, otherCell.elevation
        );
    }
```

使用此方法，在HexMesh.TriangulateCorner中判断两个正六边形地图块的相对高度，就可以获取其边缘类型了。代码如下：

```csharp
    private void TriangulateCorner(
        Vector3 bottom, HexCell bottomCell,
        Vector3 left, HexCell leftCell,
        Vector3 right, HexCell rightCell
    )
    {
        HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell);
        HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell);

        AddTriangle(bottom, left, right);
        AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color);
    }
```

如果L与R位置的正六边形地图块高度相同，并且都比B位置的正六边形地图块高1单位，将这种组合称为“slope-slope-flat”（简称“SSF”）。示意图如下：

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-corner-connections/ssf.png)

接下来，在HexMesh.cs中添加TriangulateCornerTerraces方法，这个方法会在构建默认的三角连接与其之前调用，这样，通过TriangulateCornerTerraces方法生成的三角形连接区域，会代替默认的三角形连接区域。代码如下：

```csharp
    private void TriangulateCorner(
        Vector3 bottom, HexCell bottomCell,
        Vector3 left, HexCell leftCell,
        Vector3 right, HexCell rightCell
    )
    {
        HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell);
        HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell);

        if (leftEdgeType == HexEdgeType.Slope)
        {
            if (rightEdgeType == HexEdgeType.Slope)
            {
                TriangulateCornerTerraces(
                    bottom, bottomCell, left, leftCell, right, rightCell
                );
                return;
            }
        }

        AddTriangle(bottom, left, right);
        AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color);
    }

    private void TriangulateCornerTerraces(
        Vector3 begin, HexCell beginCell,
        Vector3 left, HexCell leftCell,
        Vector3 right, HexCell rightCell
    )
    {

    }
```

这样，当地形中某三个相邻的正六边形地图块符合SSF这种组合的时候，它们之间的三角形连接区域就会变成空的，效果如下图：

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-corner-connections/hole.png)

接下来填补该区域的思路，与生成“过渡台阶”的思路类似，首先需要构建最底部第一个“过渡台阶”的斜边，代码与运行效果图如下：

```csharp
private void TriangulateCornerTerraces(
        Vector3 begin, HexCell beginCell,
        Vector3 left, HexCell leftCell,
        Vector3 right, HexCell rightCell
    )
    {
        Vector3 v3 = HexMetrics.TerraceLerp(begin, left, 1);
        Vector3 v4 = HexMetrics.TerraceLerp(begin, right, 1);
        Color c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, 1);
        Color c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, 1);

        AddTriangle(begin, v3, v4);
        AddTriangleColor(beginCell.color, c3, c4);
    }
```

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-corner-connections/first-step.png)

同样，在构建好第一个“过渡台阶”的斜边后，直接将剩余部分填充完，这里与之前有一个却别，就是在着色时要处理4个颜色，而不是3个.所以要添加一个AddQuadColor方法的重载，函数参数为4个颜色值，分别为4个顶点着色。代码与运行效果图如下：

```csharp
    private void AddQuadColor(Color c1, Color c2, Color c3, Color c4)
    {
        colors.Add(c1);
        colors.Add(c2);
        colors.Add(c3);
        colors.Add(c4);
    }

        private void TriangulateCornerTerraces(
        Vector3 begin, HexCell beginCell,
        Vector3 left, HexCell leftCell,
        Vector3 right, HexCell rightCell
    )
    {
        Vector3 v3 = HexMetrics.TerraceLerp(begin, left, 1);
        Vector3 v4 = HexMetrics.TerraceLerp(begin, right, 1);
        Color c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, 1);
        Color c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, 1);

        AddTriangle(begin, v3, v4);
        AddTriangleColor(beginCell.color, c3, c4);

        AddQuad(v3, v4, left, right);
        AddQuadColor(c3, c4, leftCell.color, rightCell.color);
    }
```

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-corner-connections/last-step.png)

最后，与生成“过渡台阶”相同，通过循环来生成中间“台阶”部分的三角面片，同时对顶点进行着色。代码与运行效果图如下：

```csharp
        for (int i = 2; i < HexMetrics.terraceSteps; i++)
        {
            Vector3 v1 = v3;
            Vector3 v2 = v4;
            Color c1 = c3;
            Color c2 = c4;
            v3 = HexMetrics.TerraceLerp(begin, left, i);
            v4 = HexMetrics.TerraceLerp(begin, right, i);
            c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i);
            c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, i);
            AddQuad(v1, v2, v3, v4);
            AddQuadColor(c1, c2, c3, c4);
        }
```

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-corner-connections/all-steps.png)

#### 31. SSF类型的变体
SSF类型根据位置不同，在地形中还有两种变体，分别为SFS和FSS，如下图所示：

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-corner-connections/sfs-fss.png)

根据SFS和FSS这两种组合，需要在TriangulateCorner方法中添加相应的判断，来生成它们之间的三角形连接区域。代码与运行效果图如下：

```csharp
        if (leftEdgeType == HexEdgeType.Slope)
        {
            if (rightEdgeType == HexEdgeType.Slope)
            {
                TriangulateCornerTerraces(
                    bottom, bottomCell, left, leftCell, right, rightCell
                );
                return;
            }
            if (rightEdgeType == HexEdgeType.Flat)
            {
                TriangulateCornerTerraces(
                    left, leftCell, right, rightCell, bottom, bottomCell
                );
                return;
            }
        }
        if (rightEdgeType == HexEdgeType.Slope)
        {
            if (leftEdgeType == HexEdgeType.Flat)
            {
                TriangulateCornerTerraces(
                    right, rightCell, bottom, bottomCell, left, leftCell
                );
                return;
            }
        }
```

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/terraced-corner-connections/all-simple-slopes.png)

至此，SSF、SFS、FSS三种组合下，三角形连接区域都已经正确的生成了三角形连接区域。剩余部分就是高差大于1个单位的各类组合。这种组合相较于高差为1个单位的组合更加复杂，下面会进行分类处理。

#### 32. 斜坡和悬崖类型的组合
SSF、SFS、FSS三种组合处理完成后，接下来需要找到高度差大于1单位的组合，这里从最简单的两种组合开始，即：
第一种，B高度为0，L高度为1，R高度为2。
第二种，B高度为0，L高度为1，R高度大于2。
如下图所示：

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/merging-slopes-and-cliffs/two-slopes-one-cliff.png)
![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/merging-slopes-and-cliffs/one-slope-two-cliffs.png)

这两种组合，可以称为SCS和SCC组合。

![](https://catlikecoding.com/unity/tutorials/hex-map/part-3/merging-slopes-and-cliffs/scs-scc.png)

在HexMesh.cs中添加一个处理这两种组合的方法，代码如下：

```csharp
    private void TriangulateCornerTerracesCliff(
        Vector3 begin, HexCell beginCell,
        Vector3 left, HexCell leftCell,
        Vector3 right, HexCell rightCell
    )
    {

    }
```

接下来，与之前调用TriangulateCornerTerraces方法相同，也是在生成三角形连接区域之前调用，代码如下：

```csharp
            if (rightEdgeType == HexEdgeType.Slope)
            {
                TriangulateCornerTerraces(bottom, bottomCell, left, leftCell, right, rightCell);
                return;
            }
            if (rightEdgeType == HexEdgeType.Flat)
            {
                TriangulateCornerTerraces(left, leftCell, right, rightCell, bottom, bottomCell);
                return;
            }
            TriangulateCornerTerracesCliff(bottom, bottomCell, left, leftCell, right, rightCell);
            return;
        }
        if (rightEdgeType == HexEdgeType.Slope)
        {
            if (leftEdgeType == HexEdgeType.Flat)
            {
                TriangulateCornerTerraces(right, rightCell, bottom, bottomCell, left, leftCell);
                return;
            }
        }
```

TriangulateCornerTerracesCliff方法调用位置确定后，接下来的问题就是如何对该连接区域进行三角剖分的问题了，这里将该区域分为两个部分进行扫脚剖分。第一部分是底部，也就是与“过渡台阶”相连接的部分。第二部分是顶部，也就是与矩形连接区域相连接的部分。

#### 33. 连接区域底部的三角剖分









```csharp

```

![]()