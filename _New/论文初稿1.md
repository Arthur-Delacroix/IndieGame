## HexMap相关
- [教程目录](https://catlikecoding.com/unity/tutorials/hex-map/)

#### 前言
当今，许多的主流策略类型的游戏都在使用网格地图(HexGrid)，其中包括《奇迹时代3》、《文明6》、《无尽传奇》、《英雄无敌》等著名的3A游戏。网格地图具有生成快速、完全程序化控制、易于解析和存储等优势，相比于用传统美术等方式制作游戏地图，对移动端设备更加友好，可以大幅度减少美术资源数量，安装包更小，更容易被用户接受。

#### 1. HexMap形状
在传统的回合制游戏中，尤其是日式RPG游戏，大多使用正方形网格地图
在大多数回合策略游戏中，使用对网格地图通常有两种：正方形和正六边形。目前，越来越多的游戏已经逐渐从正方形转变到了正六边形。

为什么使用六边形的网格地图？在传统游戏中，尤其是传统的日式RPG中，大量的使用了正方形的网格地图。正方形网格相比其他形状，更容易绘制和定位。但是正方形网格也有明显的缺点，下图为一个正方形网格：

![一个正方形网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/square-grid.png)

中间这个正方形网格中，一共有8个与其相邻的网格。与中间正方形网格边相邻的网格，称为水平和垂直相邻，与中间正方形网格对角相邻的网格，称为对角相邻。
从上图中可以看出，如果每个正方形网格的边长为1，那么，水平和垂直相邻的正方形网格中点之间的距离也为1.但是，对角相邻的正方形网格中点之间的距离，为$\sqrt{ 2 }$。
两种形式的相邻网格，造成了距离的差异化。在游戏中，如果一个人物在正方形网格中进行移动，这种距离的差异化将会更加明显。为了避免这种差异化，不同的游戏使用了不同的方法，也有不同的有点和缺点。其中一种方法，就是使用正六边形网格代替传统的正方形网格。

![六边形网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/hexagon-grid.png)

与正方形网格相比，在正六边形网格中，每个地图块之间中点的距离都是相等的，这样就避免了距离的差异化。当然，使用正六边形网格也会有其他的问题，不过相对于距离差异化更容易解决。

![六边形的内外半径](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/hexagon.png)

在开始设计正六边形网格地图之前，必须先确定每个正六边形地图块的边长。如果一个正六边形地图块的边长为10，那么，这个正六边形地图块的外接圆半径也是10。
每个正六边形网格还有一个内切圆，根据勾股定理可以得出，其内切圆的半径为 $\frac{ \sqrt{ 3 } }{ 2 }$ 倍的边长，得出内切圆半径为 $5\sqrt{ 3 }$。
接下来，将这两个常量保存至一个静态类中，便于访问。代码如下：

```csharp
using UnityEngine;

public static class HexMetrics
{
	public const float outerRadius = 10f;

	public const float innerRadius = outerRadius * 0.866025404f;
}
```

确定了整列变形地图块的外接圆和内切圆半径后，接下来需要确定正六边形网格中，每个正六边形地图块的摆放姿态。
在正六边形网格中，每个正六边形地图块会有两种摆放姿态，顶点朝上或者边朝上。

![正六边形地图块的摆放姿态](https://catlikecoding.com/unity/tutorials/hex-map/part-1/about-hexagons/orientations.png)

为了方便计算与排列，这里选择顶点朝上的排列方式，并将正六边形网格放置在XZ平面上。从正六边形地图块正上方一个顶点的位置开始，顺时针排列一个其相邻的六个地图块。以下代码为记录每个正六边形地图块其六个顶点位置：

```csharp
    public static Vector3[] corners =
    {
        new Vector3(0f, 0f, outerRadius),
        new Vector3(innerRadius, 0f, 0.5f * outerRadius),
        new Vector3(innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(0f, 0f, -outerRadius),
        new Vector3(-innerRadius, 0f, -0.5f * outerRadius),
        new Vector3(-innerRadius, 0f, 0.5f * outerRadius)
    };
```

#### 2. 创建地图网格
要创建一个正六边形网格，需要先创建单个的正六边形地图块。在Unity3D中，可以将一个正六边形地图块制作为Prefab，方便程序引用和统一修改。讲每个正六边形地图块称为HexCell，并串讲基础脚本：

```csharp
using UnityEngine;

public class HexCell : MonoBehaviour
{
}
```

创建正六边形地图块Prefab非常简单，首先，在场景中创建一个Plane，并挂载HexCell.cs脚本，然后将其转换成Prefab，结果如下图：

![使用plane作为HexCell Prefab](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/hex-cell-plane.png)

接下来，要创建一个容器，用来实例化正六边形地图块，并将每个地图块有序的排列起来。其名称为HexGrid。脚本与参数如下图：

```csharp
using UnityEngine;

public class HexGrid : MonoBehaviour
{
    public int width = 6;
    public int height = 6;

    public HexCell cellPrefab;
}
```

![HexGrid 属性](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/hex-grid.png)

由于HexCell使用了Plane网格，Plane网格默认为 10x10 单位长度，所以在实例化HexCell时，需要加上边长的偏移量。实例化HexCell代码与生成无缝单元网格效果如下：

```csharp
    private HexCell[] cells;

    void Awake()
    {
        cells = new HexCell[height * width];

        for (int z = 0, i = 0; z < height; z++)
        {
            for (int x = 0; x < width; x++)
            {
                CreateCell(x, z, i++);
            }
        }
    }

    void CreateCell(int x, int z, int i)
    {
        Vector3 position;
        position.x = x * 10f;
        position.y = 0f;
        position.z = z * 10f;

        HexCell cell = Instantiate<HexCell>(cellPrefab);
        cells[i] = cell;

        cell.transform.SetParent(transform, false);
        cell.transform.localPosition = position;
    }
```

![生成的无缝单元网格](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/square-grid-of-planes.png)

虽然按照程序生成了相应网格，但是在程序调试过程中无法判断每个HexCell的位置，如果HexCell为正六边形，这个问题将会更加棘手。

#### 3. 显示坐标
要显示每个HexCell的坐标，可以使用Unity3D的UGUI系统来实现。创建一个Canvas，并将其设置为HexGrid的子物体。因为目前功能只需要显示坐标，不需要任何触发，所以删除Canvas上的Graphic Raycaster组件。下图为HexGridCanvas参数设置：

![HexGridCanvas参数设置](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/canvas.png)

在Unity3D UGUI中，Canvas是承载UI元素的容器，要显示每个HexCell的坐标，需要在Canvas容器中创建一个Text对象，并将这个Text对象转换为Prefab。Text对象的参数设置如下图：

![Text对象参数设置 1](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/label-part-1.png)
![Text对象参数设置 2](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/label-part-2.png)

接下来，要在初始化HexCell时，同时初始化HexCellLabel，并且让每一个HexCellLabel与HexCell对齐，修改HexGrid.cs脚本与运行效果如下：
```csharp
using UnityEngine.UI;

    public Text cellLabelPrefab;

	Canvas gridCanvas;

	void Awake ()
    {
		gridCanvas = GetComponentInChildren<Canvas>();
		
		…
	}

    void CreateCell (int x, int z, int i)
    {
		…

		Text label = Instantiate<Text>(cellLabelPrefab);
		label.rectTransform.SetParent(gridCanvas.transform, false);
		label.rectTransform.anchoredPosition = new Vector2(position.x, position.z);
		label.text = x.ToString() + "\n" + z.ToString();
	}
```
![显示地图块的坐标](https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/grid-with-labels.png)

#### 4. 设置地图块的位置